{"version":3,"file":"liquicode.js","mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;;;;;;;;;ACVa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM,YAAY;AAC5D;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC;AAClD,cAAc,4CAA4C,8BAA8B;AACxF,cAAc,kFAAkF;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK,YAAY;AAC3D;AACA;AACA;AACA;AACA,iDAAiD,YAAY;AAC7D;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,EAAE,sEAAyB;AAC9C;AACA,UAAU,mBAAO,EAAE,kEAAuB;AAC1C;AACA,WAAW,mBAAO,EAAE,oEAAwB;AAC5C,aAAa,mBAAO,EAAE,wEAA0B;AAChD,YAAY,mBAAO,EAAE,sEAAyB;AAC9C;AACA;AACA;;;;;;;;;;;ACtRa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D;;AAEA,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,0BAA0B;AAC1B,mEAAmE;AACnE,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa,qBAAqB,YAAY;AAC/D;AACA;AACA;AACA;AACA,iBAAiB,YAAY,sBAAsB;AACnD;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,kCAAkC,OAAO,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,aAAa,qBAAqB,YAAY;;AAE/D;AACA;AACA;AACA,iBAAiB,YAAY,sBAAsB;;AAEnD;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,kCAAkC,OAAO,UAAU;AACnD;AACA;;AAEA,YAAY,GAAG;AACf;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC;AACjC;AACA;AACA;AACA,qCAAqC;AACrC,oCAAoC;AACpC,iCAAiC;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC;AACjC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sCAAsC;AACtC,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,kBAAkB;AACjF,wFAAwF,kBAAkB;AAC1G;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,SAAS;AACzE;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9Ta;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kBAAkB;AAClB,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kBAAkB;AAClB,6BAA6B;AAC7B,4BAA4B;AAC5B,wBAAwB;AACxB;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,EAAE;AACF,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kBAAkB;AAClB,6BAA6B;AAC7B,4BAA4B;AAC5B;AACA,EAAE;AACF,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,kBAAkB;AAClB,6BAA6B;AAC7B,4BAA4B;AAC5B,wBAAwB;AACxB;AACA,EAAE;AACF,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oDAAoD;AACpD;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB;AACA,8BAA8B,oCAAoC;AAClE;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,iCAAiC;AACjC,wDAAwD;AACxD,gCAAgC;AAChC,wDAAwD;AACxD,gCAAgC;AAChC,yDAAyD;AACzD,iCAAiC;AACjC,0DAA0D;AAC1D,iCAAiC;AACjC,0DAA0D;AAC1D,iCAAiC;AACjC,0DAA0D;AAC1D,iCAAiC;AACjC,0DAA0D;AAC1D,iCAAiC;AACjC;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,iCAAiC;AACjC,wDAAwD;AACxD,gCAAgC;AAChC,wDAAwD;AACxD,gCAAgC;AAChC,yDAAyD;AACzD;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,gCAAgC;AAChC,wDAAwD;AACxD,gCAAgC;AAChC,wDAAwD;AACxD,gCAAgC;AAChC,wDAAwD;AACxD;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,4BAA4B;AAC5B,sCAAsC;AACtC;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,qCAAqC;AACrC;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,qCAAqC;AACrC,2BAA2B;AAC3B,yBAAyB,sBAAsB;AAC/C;AACA,kDAAkD;AAClD;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,qCAAqC;AACrC,2BAA2B;AAC3B,yBAAyB,sBAAsB;AAC/C;AACA,iDAAiD;AACjD;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,qCAAqC;AACrC,2BAA2B;AAC3B,yBAAyB,sBAAsB;AAC/C;AACA,iDAAiD;AACjD;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,qCAAqC;AACrC,2BAA2B;AAC3B,yBAAyB,sBAAsB;AAC/C;AACA,iDAAiD;AACjD;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,oBAAoB;AACpB,qCAAqC;AACrC,2BAA2B;AAC3B,yBAAyB,sBAAsB;AAC/C;AACA,iDAAiD;AACjD,+CAA+C;AAC/C;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjfa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA,cAAc,YAAY,GAAG,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,GAAG;AACf;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;AACA,sBAAsB,YAAY,GAAG,cAAc;AACnD;AACA;AACA;AACA;AACA,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ga;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,mBAAO,EAAE,mEAAuB;AACzC,SAAS,mBAAO,EAAE,mEAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAO,EAAE,yEAA0B;AAC/C,iBAAiB,mBAAO,EAAE,mFAA+B;AACzD,UAAU,mBAAO,EAAE,qEAAwB;AAC3C;AACA,WAAW,mBAAO,EAAE,uEAAyB;AAC7C,SAAS,mBAAO,EAAE,mEAAuB;AACzC;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/Ca;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,0CAA0C;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChHa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO,6BAA6B,UAAU,GAAG,UAAU;AAClG;AACA;AACA;AACA,uCAAuC,SAAS,0BAA0B,YAAY;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7Pa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,WAAW;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA,YAAY,GAAG;AACf;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB,EAAE,MAAM,EAAE,sBAAsB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,2BAA2B,qCAAqC,iCAAiC;AACjG,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB,EAAE,IAAI,EAAE,yBAAyB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/Ka;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;;AAGA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;;AAGA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qCAAqC;AACpE;AACA;AACA;AACA,kDAAkD;AAClD,0CAA0C;AAC1C,mBAAmB,YAAY;AAC/B;AACA,8BAA8B,iCAAiC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU,GAAG,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAO,EAAE,iEAAuB;AAC3C,WAAW,mBAAO,EAAE,iEAAuB;AAC3C;AACA,qBAAqB,mBAAO,EAAE,qFAAiC;AAC/D,eAAe,mBAAO,EAAE,yEAA2B;AACnD,eAAe,mBAAO,EAAE,yEAA2B;AACnD,kBAAkB,mBAAO,EAAE,+EAA8B;AACzD;AACA,aAAa,mBAAO,EAAE,qEAAyB;AAC/C,kBAAkB,mBAAO,EAAE,+EAA8B;AACzD,YAAY,mBAAO,EAAE,mEAAwB;AAC7C,kBAAkB,mBAAO,EAAE,+EAA8B;AACzD;AACA;AACA;;;;;;;;;;;ACzCa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,yCAAyC;AACrH,4EAA4E,yCAAyC;AACrH,6FAA6F,0CAA0C;AACvI;AACA;AACA;AACA,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uBAAuB;AACrE,gCAAgC,0DAA0D;AAC1F,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,0CAA0C;AAC1C,+CAA+C;AAC/C,kCAAkC;AAClC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,4BAA4B;AAC5B,aAAa,iCAAiC,EAAE,gBAAgB,EAAE,kDAAkD;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;;AAGA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,iEAAiE;AACjE,6DAA6D;AAC7D,yCAAyC;AACzC,uCAAuC;AACvC;AACA;AACA;AACA,4BAA4B;AAC5B,gCAAgC;AAChC;AACA;AACA;AACA,0BAA0B;AAC1B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Ga;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,iEAAiE;AACjE,6DAA6D;AAC7D,yCAAyC;AACzC,uCAAuC;AACvC,+CAA+C;AAC/C,kCAAkC;AAClC,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA,gCAAgC;AAChC,+CAA+C,UAAU,EAAE,WAAW,EAAE,QAAQ,MAAM,UAAU,EAAE,gBAAgB,EAAE,QAAQ;AAC5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjIa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ea;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAO,EAAE,qEAAwB;AAC3C;AACA;AACA;AACA;;;;;;;;;;;AC/Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sBAAsB;AAC1E;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA,YAAY,QAAQ;AACpB;AACA,YAAY,QAAQ,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA;AACA,wDAAwD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,0BAA0B,gBAAgB;AAC1C;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE,yBAAyB;AACzB;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA,sBAAsB;AACtB;AACA;AACA,yBAAyB,wBAAwB;AACjD;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+BAA+B,eAAe;AACpG,gCAAgC,oCAAoC;AACpE;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,eAAe;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,2BAA2B;AAC3B,2BAA2B;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,kEAAkE;AAClE,wBAAwB;AACxB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,+BAA+B,eAAe;AACpG;AACA,kCAAkC;AAClC,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iEAAiE;AACjE,uEAAuE;AACvE;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iEAAiE;AACjE,uEAAuE;AACvE;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8BAA8B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC,wEAAwE;AACxE,8BAA8B;AAC9B;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,iEAAiE;AACjE;AACA,6BAA6B,iCAAiC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,uCAAuC;AACvC;AACA,6BAA6B,sBAAsB;AACnD;AACA,kEAAkE;AAClE;AACA;AACA,iCAAiC,4BAA4B;AAC7D;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,6BAA6B;AAC7B;AACA;AACA,6BAA6B,8BAA8B;AAC3D;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,6BAA6B;AAC7D;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAiD;AAC5E;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAiD;AAC5E;AACA;AACA,UAAU;AACV,4BAA4B,iBAAiB,qCAAqC;AAClF,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAiD;AAC5E;AACA;AACA,UAAU;AACV,4BAA4B,iBAAiB,sCAAsC;AACnF,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iDAAiD;AAC5E;AACA;AACA,UAAU;AACV,4BAA4B,iBAAiB,qCAAqC;AAClF,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,4BAA4B,iBAAiB,sCAAsC;AACnF,QAAQ;AACR;AACA;AACA;AACA,wEAAwE,SAAS;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAA2B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4BAA4B;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChxCa;;;AAGb;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,EAAE,oFAAgC;AAC5D,YAAY,mBAAO,EAAE,sEAAyB;AAC9C,aAAa,mBAAO,EAAE,wEAA0B;AAChD;AACA;;;;;;;;;;;;AC9Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,qCAAqC;AACrC,wCAAwC;AACxC,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,WAAW;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB,2DAA2D,MAAM;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,0BAA0B;AAC1B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,2CAA2C;AAC3C,sDAAsD;AACtD;AACA,0BAA0B;AAC1B;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Sa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C;AAC7C,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,sBAAsB,qCAAqC;AAC3D;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,yBAAyB;AACzB,uBAAuB;AACvB,wBAAwB;AACxB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kCAAkC;AAChE,gCAAgC,aAAa,OAAO,OAAO;AAC3D,qCAAqC,YAAY,OAAO,OAAO;AAC/D,qCAAqC,aAAa,OAAO,KAAK;AAC9D;AACA;AACA;AACA,qBAAqB,KAAK,EAAE,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,YAAY,GAAG,aAAa,GAAG,YAAY,EAAE,aAAa,EAAE,YAAY;AACxF;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzda;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAO,EAAE,uFAAiC;AAC7D,cAAc,mBAAO,EAAE,6EAA4B;AACnD,cAAc,mBAAO,EAAE,6EAA4B;AACnD,gBAAgB,mBAAO,EAAE,iFAA8B;AACvD,cAAc,mBAAO,EAAE,6EAA4B;AACnD,gBAAgB,mBAAO,EAAE,iFAA8B;AACvD,eAAe,mBAAO,EAAE,+EAA6B;AACrD,gBAAgB,mBAAO,EAAE,iFAA8B;AACvD;AACA;AACA,cAAc,mBAAO,EAAE,6EAA4B;AACnD,kBAAkB,mBAAO,EAAE,qFAAgC;AAC3D,uBAAuB,mBAAO,EAAE,+FAAqC;AACrE,gBAAgB,mBAAO,EAAE,iFAA8B;AACvD,eAAe,mBAAO,EAAE,+EAA6B;AACrD;AACA;AACA,mBAAmB,mBAAO,EAAE,uFAAiC;AAC7D,gBAAgB,mBAAO,EAAE,iFAA8B;AACvD,kBAAkB,mBAAO,EAAE,qFAAgC;AAC3D,iBAAiB,mBAAO,EAAE,mFAA+B;AACzD,iBAAiB,mBAAO,EAAE,mFAA+B;AACzD;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,kBAAkB,mBAAO,EAAE,kBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yCAAyC;AACvH;AACA,6CAA6C;AAC7C;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChKa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,kBAAkB,mBAAO,EAAE,kBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,yCAAyC;AACvH;AACA,6CAA6C;AAC7C;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChKa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,kBAAkB,mBAAO,EAAE,kBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C,gCAAgC,kBAAkB;AAClD;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjHa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,kBAAkB,mBAAO,EAAE,kBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;;AAEA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,kBAAkB,mBAAO,EAAE,kBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClGa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,8CAA8C;AAC9C,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrFa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,2BAA2B,mBAAO,EAAE,oCAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Fa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,2BAA2B,mBAAO,EAAE,oCAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,EAAE,cAAI;AAC7B,2BAA2B,mBAAO,EAAE,oCAAe;AACnD;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtEa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY;AACnD;AACA;AACA;AACA,8DAA8D,YAAY,2BAA2B,YAAY,QAAQ;AACzH,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/Da;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,iDAAiD;AACjD,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,iDAAiD;AACjD,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD,GAAG;AACH;;;AAGA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,yBAAyB,8BAA8B;AACvD;AACA;AACA,4BAA4B,eAAe,GAAG,eAAe;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C,yBAAyB,gCAAgC;AACzD;AACA;AACA,4BAA4B,iBAAiB,GAAG,iBAAiB;AACjE,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,yBAAyB,qBAAqB;AAC9C;AACA;AACA,6BAA6B,KAAK,GAAG,4BAA4B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChLa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,YAAY;AAChD;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrDa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAO,EAAE,8FAAoC;AAClE,mBAAmB,mBAAO,EAAE,0FAAkC;AAC9D;AACA;;;;;;;;;;;AC/Ba;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,EAAE,kBAAM;AACjC,mBAAmB,mBAAO,EAAE,oBAAO;AACnC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,yDAAyD;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Ea;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,EAAE,kBAAM;AACjC,mBAAmB,mBAAO,EAAE,oBAAO;AACnC;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,yDAAyD;AACzD,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9Ea;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAO,EAAE,8DAA0B;AACrD,mBAAmB,mBAAO,EAAE,kEAA4B;AACxD,iBAAiB,mBAAO,EAAE,0DAAwB;AAClD,mBAAmB,mBAAO,EAAE,kEAA4B;AACxD,kBAAkB,mBAAO,EAAE,8DAA0B;AACrD,mBAAmB,mBAAO,EAAE,kEAA4B;AACxD,oBAAoB,mBAAO,EAAE,sEAA8B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1BA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;UCAA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;UEtBA;UACA;UACA;UACA","sources":["webpack://@liquicode/liquicodejs/webpack/universalModuleDefinition","webpack://@liquicode/liquicodejs/./src/000-Types/000-Types.js","webpack://@liquicode/liquicodejs/./src/000-Types/001-Types.HasValue.js","webpack://@liquicode/liquicodejs/./src/000-Types/010-Types.Coerce.js","webpack://@liquicode/liquicodejs/./src/000-Types/020-Types.Formats.js","webpack://@liquicode/liquicodejs/./src/000-Types/021-Types.GetFormat.js","webpack://@liquicode/liquicodejs/./src/000-Types/022-Types.IsFormat.js","webpack://@liquicode/liquicodejs/./src/100-Object/100-Object.js","webpack://@liquicode/liquicodejs/./src/100-Object/101-Object.Clone.js","webpack://@liquicode/liquicodejs/./src/100-Object/103-Object.Merge.js","webpack://@liquicode/liquicodejs/./src/100-Object/120-Object.FromJson.js","webpack://@liquicode/liquicodejs/./src/100-Object/121-Object.ToJsonOptions.js","webpack://@liquicode/liquicodejs/./src/100-Object/122-Object.ToJson.js","webpack://@liquicode/liquicodejs/./src/100-Object/125-Object.FromIni.js","webpack://@liquicode/liquicodejs/./src/100-Object/126-Object.ToIni.js","webpack://@liquicode/liquicodejs/./src/200-Text/200-Text.js","webpack://@liquicode/liquicodejs/./src/200-Text/202-Text.Compare.js","webpack://@liquicode/liquicodejs/./src/200-Text/203-Text.Matches.js","webpack://@liquicode/liquicodejs/./src/200-Text/210-Text.ReplaceCharacters.js","webpack://@liquicode/liquicodejs/./src/200-Text/211-Text.ReplaceText.js","webpack://@liquicode/liquicodejs/./src/200-Text/213-Text.FindBetween.js","webpack://@liquicode/liquicodejs/./src/200-Text/214-Text.ReplaceBetween.js","webpack://@liquicode/liquicodejs/./src/200-Text/220-Text.FirstWord.js","webpack://@liquicode/liquicodejs/./src/200-Text/221-Text.AfterFirstWord.js","webpack://@liquicode/liquicodejs/./src/200-Text/222-Text.LastWord.js","webpack://@liquicode/liquicodejs/./src/200-Text/223-Text.BeforeLastWord.js","webpack://@liquicode/liquicodejs/./src/300-Shapes/300-Shapes.js","webpack://@liquicode/liquicodejs/./src/300-Shapes/310-Shapes.Matrix.js","webpack://@liquicode/liquicodejs/./src/500-Parse/500-Parse.js","webpack://@liquicode/liquicodejs/./src/500-Parse/501-Parse.TokenizeOptions.js","webpack://@liquicode/liquicodejs/./src/500-Parse/502-Parse.Tokenize.js","webpack://@liquicode/liquicodejs/./src/500-Parse/510-Parse.DateParse.js","webpack://@liquicode/liquicodejs/./src/800-System/800-System.js","webpack://@liquicode/liquicodejs/./src/800-System/810-System.AsyncVisitFiles.js","webpack://@liquicode/liquicodejs/./src/800-System/810-System.VisitFiles.js","webpack://@liquicode/liquicodejs/./src/800-System/811-System.CountFiles.js","webpack://@liquicode/liquicodejs/./src/800-System/812-System.CountFolders.js","webpack://@liquicode/liquicodejs/./src/800-System/813-System.CopyFolder.js","webpack://@liquicode/liquicodejs/./src/800-System/814-System.DeleteFolder.js","webpack://@liquicode/liquicodejs/./src/800-System/815-System.EmptyFolder.js","webpack://@liquicode/liquicodejs/./src/800-System/816-System.WithFileText.js","webpack://@liquicode/liquicodejs/./src/800-System/820-System.AsyncSleep.js","webpack://@liquicode/liquicodejs/./src/800-System/821-System.ExecuteProcess.js","webpack://@liquicode/liquicodejs/./src/800-System/822-System.AsyncExecuteProcess.js","webpack://@liquicode/liquicodejs/./src/800-System/823-System.StartProcess.js","webpack://@liquicode/liquicodejs/./src/800-System/824-System.StopProcess.js","webpack://@liquicode/liquicodejs/./src/800-System/830-System.ContainerStatus.js","webpack://@liquicode/liquicodejs/./src/800-System/831-System.RunContainer.js","webpack://@liquicode/liquicodejs/./src/800-System/832-System.StartContainer.js","webpack://@liquicode/liquicodejs/./src/800-System/833-System.StopContainer.js","webpack://@liquicode/liquicodejs/./src/800-System/834-System.KillContainer.js","webpack://@liquicode/liquicodejs/./src/900-Network/900-Network.js","webpack://@liquicode/liquicodejs/./src/900-Network/910-Network.AsyncDownloadFile.js","webpack://@liquicode/liquicodejs/./src/900-Network/920-Network.AsyncGetRequest.js","webpack://@liquicode/liquicodejs/./src/liquicode-node.js","webpack://@liquicode/liquicodejs/external node-commonjs \"child_process\"","webpack://@liquicode/liquicodejs/external node-commonjs \"fs\"","webpack://@liquicode/liquicodejs/external node-commonjs \"http\"","webpack://@liquicode/liquicodejs/external node-commonjs \"https\"","webpack://@liquicode/liquicodejs/external node-commonjs \"path\"","webpack://@liquicode/liquicodejs/webpack/bootstrap","webpack://@liquicode/liquicodejs/webpack/before-startup","webpack://@liquicode/liquicodejs/webpack/startup","webpack://@liquicode/liquicodejs/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(global, () => {\nreturn ","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '000',\r\n\tname: 'Types',\r\n\ttype: 'namespace',\r\n\tsummary: 'Data Type Handling',\r\n\tdescription: [ `\r\nLiquicodeJS can classify and identify value types beyond the primitive data types supported by Javascript.\r\n\r\n\r\nWhen obtaining FieldSchema objects from \\`Schema.ValueSchema()\\` or \\`Schema.ObjectSchema()\\`,\r\n\\`FieldSchema.type\\` will contain the Javascript data type and \\`FieldSchema.format\\` will have a more specific type description.\r\n\r\nJavascript (and JSON) offers four data types for your variable values: \\`boolean\\`, \\`number\\`, \\`string\\`,\r\nand everything else is essentially an \\`object\\`.\r\nThis suits Javascript well for the types of things that Javascript needs to do like storing values in memory\r\nand executing program statements with those values.\r\nThis is not always great on an application level though.\r\nWhen you need to, for example, make sure that a variable contains an \\`array\\` of \\`string\\` or that value represents a floating point number.\r\nCases like these require additional progrma statements and type checking which can be consolidated into a set of functions.\r\n\r\nThe \\`Schema\\` module defines a few objects and functions to alleviate this burden from the application developer.\r\n\r\n**The FieldSchema Object**\r\n\r\nThis object describes a value (or field) with greater precision then Javascript's \\`typeof\\` statement.\r\nThe \\`FieldSchema.type\\` member will always contain a Javascript data type while the \\`FieldSchema.format\\` field contains a more\r\ndetailed data type.\r\n\r\n~~~javascript\r\nFieldSchema = {\r\n\ttype: '',\t\t\t\t// Javascript data type (boolean, number, string, or object).\r\n\tformat: '',\t\t\t\t// A data type specific designation.\r\n\tdefault: undefined,\t\t// A default value used for missing fields.\r\n\tname: '',\t\t\t\t// Name of the field.\r\n}\r\n~~~\r\n\r\nThese functions will generate a \\`FieldSchema\\` from a single value or an object.\r\nBe aware that only the top level members of an object are scrutinized as this is what we are typically interested in most cases.\r\nFunctions of the \\`Schema\\` module do not recurse into an object providing the schema for every single field in the object.\r\nRather, they inspect the top level of objects only and return an array of schema objects as a result.\r\nAgain, this handles most use cases with a consistent set of functions.\r\nAny further validation/coercion that may be required can also be perfomed by the same functions on an individual case basis.\r\n\r\n- \\`Schema.ValueSchema( FromValue )\\`\r\n- \\`Schema.ObjectSchema( FromObject )\\`\r\n\r\nPossible values for \\`FieldSchema.type\\` and \\`FieldSchema.format\\` are as follows:\r\n\r\n| Type    | Format        | Default Value | Examples                              |\r\n|---------|---------------|---------------|---------------------------------------|\r\n| boolean | boolean       | false         | \\`true\\`, or \\`false\\`                |\r\n| number  | integer       | 0             | \\`1\\`, \\`2\\`, or \\`3.0\\`              |\r\n| number  | float         | 0             | \\`1.1\\`, \\`2.071\\`, or \\`3.14\\`       |\r\n| string  | string        | \"\"            | \\`\"Hello\"\\`, or \\`\"\"\\`                |\r\n| object  | object        | {}            | \\`{ foo: 'bar' }\\`                    |\r\n| object  | array         | []            | \\`[ 1, 'two', 3.14, null ]\\`          |\r\n| object  | boolean-array | []            | \\`[ true, false, true ]\\`             |\r\n| object  | number-array  | []            | \\`[ 1, 2, 3.14 ]\\`                    |\r\n| object  | string-array  | []            | \\`[ 'one', 'two', 'three' ]\\`         |\r\n| object  | object-array  | []            | \\`[ { foo: 'bar' }, [1,2,3], null ]\\` |\r\n| object  | array-array   | []            | \\`[ [1,2,3], [], [4,5] ]\\`            |\r\n`,\r\n\t\t`\r\n\r\n**The ErrorValue Object**\r\n\r\nLiquicodeJS introduces an \\`ErrorValue\\` object that is used to indicate and convey errors.\r\nSome functions will return an \\`ErrorValue\\` object instead of throwing a Javascript \\`Error\\`.\r\nIn some cases, this can make code more efficient and legible when certain errors are tolerable\r\nand you want to avoid the expensive cost of a Javascript \\`Error\\` that includes a call stack.\r\n\r\nUse the \\`Schema.ErrorValue()\\` function to create an \\`ErrorValue\\` object and \\`Schema.IsErrorValue()\\` to test for errors.\r\nAn \\`ErrorValue\\` will always have \\`ErrorValue.ok = false\\` and \\`ErrorValue.error\\` will contain the error message.\r\n\r\n~~~javascript\r\nErrorValue = {\r\n\tok: false,\t\t// Always set to \"false\".\r\n\terror: '',\t\t// Error message.\r\n\tcontext: '',\t// Context for the error (e.g. a function name).\r\n}\r\n~~~\r\n`,\r\n\t\t`\r\n\r\n**Value Coercion**\r\n\r\nAs data gets shuttled around between memory, files, and network transmissions, the representation of the data might\r\nchange to suit to the medium.\r\nFor example, an integer value being stored in a file might be read back out later as a string.\r\nIt's actual value hasn't changed, but the way it is represented has changed.\r\nJavascript can be pretty forgiving in these cases by allowing a certain amount of type fluidity;\r\nHowever, this can also cause some difficult to spot errors like when \\`'2' + 2\\` equals the string \\`'22'\\` and not the integer \\`4\\`.\r\n\r\nUse these functions the validate that a value's type is of an expected type and to coerce the value, in a common sense way,\r\nto that expected type.\r\n\r\n- \\`Types.Coerce( Value, Schema, ThrowErrors )\\`\r\n- \\`Types.Coerce( Value, Schema, ThrowErrors )\\`\r\n- \\`Types.Coerces( Values, Schemas, ThrowErrors )\\`\r\n\r\nThis tables describes how values are converted from one data type to another during coercion:\r\n\r\n| From Type | To Boolean     | To Number      | To String        | To Object      |\r\n|-----------|----------------|----------------|------------------|----------------|\r\n| undefined | DefaultValue() | DefaultValue() | DefaultValue()   | DefaultValue() |\r\n| null      | DefaultValue() | DefaultValue() | DefaultValue()   | DefaultValue() |\r\n| Boolean   | Value          | Number()       | toString()       | ErrorValue     |\r\n| Number    | Boolean()      | Value          | toString()       | ErrorValue     |\r\n| String    | Boolean()      | Number()       | Value            | JSON.parse()   |\r\n| Object    | Boolean()      | Number()       | JSON.stringify() | Value          |\r\n`,\r\n\t\t`\r\n\r\n**Related Reading**\r\n\r\n- [You Don't Know JS: Types & Grammar - Chapter 4. Coercion](https://www.oreilly.com/library/view/you-dont-know/9781491905159/ch04.html)\r\n`,\r\n\t],\r\n\texamples: [\r\n\t\t`Schema = { name: 'PersonName', type: 'string' }`,\r\n\t\t`Schema = { name: 'options', type: 'object', default: { hoist: true, swab: 'decks' } }`,\r\n\t\t`Schema = { name: 'max_tries', type: 'number', format: 'integer', required: true, default: 3 }`,\r\n\t],\r\n\ttodo: [\r\n\t\t'Support extended number formats: positive-integer, negative-integer, positive-float, negative-float',\r\n\t\t'Support type: function',\r\n\t\t'Support format plugin-ins. Must implement: get_default(), is_type_of(value), can_coerce(type), coerce(value)',\r\n\t],\r\n\r\n};\r\n\r\n\r\n//-start-jsdoc---------------------------------------------------------\r\n/**\n * @public\n * @namespace Types\n * @summary Data Type Handling\n * @description\n * \nLiquicodeJS can classify and identify value types beyond the primitive data types supported by Javascript.\n\n\nWhen obtaining FieldSchema objects from `Schema.ValueSchema()` or `Schema.ObjectSchema()`,\n`FieldSchema.type` will contain the Javascript data type and `FieldSchema.format` will have a more specific type description.\n\nJavascript (and JSON) offers four data types for your variable values: `boolean`, `number`, `string`,\nand everything else is essentially an `object`.\nThis suits Javascript well for the types of things that Javascript needs to do like storing values in memory\nand executing program statements with those values.\nThis is not always great on an application level though.\nWhen you need to, for example, make sure that a variable contains an `array` of `string` or that value represents a floating point number.\nCases like these require additional progrma statements and type checking which can be consolidated into a set of functions.\n\nThe `Schema` module defines a few objects and functions to alleviate this burden from the application developer.\n\n**The FieldSchema Object**\n\nThis object describes a value (or field) with greater precision then Javascript's `typeof` statement.\nThe `FieldSchema.type` member will always contain a Javascript data type while the `FieldSchema.format` field contains a more\ndetailed data type.\n\n~~~javascript\nFieldSchema = {\n\ttype: '',\t\t\t\t// Javascript data type (boolean, number, string, or object).\n\tformat: '',\t\t\t\t// A data type specific designation.\n\tdefault: undefined,\t\t// A default value used for missing fields.\n\tname: '',\t\t\t\t// Name of the field.\n}\n~~~\n\nThese functions will generate a `FieldSchema` from a single value or an object.\nBe aware that only the top level members of an object are scrutinized as this is what we are typically interested in most cases.\nFunctions of the `Schema` module do not recurse into an object providing the schema for every single field in the object.\nRather, they inspect the top level of objects only and return an array of schema objects as a result.\nAgain, this handles most use cases with a consistent set of functions.\nAny further validation/coercion that may be required can also be perfomed by the same functions on an individual case basis.\n\n- `Schema.ValueSchema( FromValue )`\n- `Schema.ObjectSchema( FromObject )`\n\nPossible values for `FieldSchema.type` and `FieldSchema.format` are as follows:\n\n| Type    | Format        | Default Value | Examples                              |\n|---------|---------------|---------------|---------------------------------------|\n| boolean | boolean       | false         | `true`, or `false`                |\n| number  | integer       | 0             | `1`, `2`, or `3.0`              |\n| number  | float         | 0             | `1.1`, `2.071`, or `3.14`       |\n| string  | string        | \"\"            | `\"Hello\"`, or `\"\"`                |\n| object  | object        | {}            | `{ foo: 'bar' }`                    |\n| object  | array         | []            | `[ 1, 'two', 3.14, null ]`          |\n| object  | boolean-array | []            | `[ true, false, true ]`             |\n| object  | number-array  | []            | `[ 1, 2, 3.14 ]`                    |\n| object  | string-array  | []            | `[ 'one', 'two', 'three' ]`         |\n| object  | object-array  | []            | `[ { foo: 'bar' }, [1,2,3], null ]` |\n| object  | array-array   | []            | `[ [1,2,3], [], [4,5] ]`            |\n\n * \n\n**The ErrorValue Object**\n\nLiquicodeJS introduces an `ErrorValue` object that is used to indicate and convey errors.\nSome functions will return an `ErrorValue` object instead of throwing a Javascript `Error`.\nIn some cases, this can make code more efficient and legible when certain errors are tolerable\nand you want to avoid the expensive cost of a Javascript `Error` that includes a call stack.\n\nUse the `Schema.ErrorValue()` function to create an `ErrorValue` object and `Schema.IsErrorValue()` to test for errors.\nAn `ErrorValue` will always have `ErrorValue.ok = false` and `ErrorValue.error` will contain the error message.\n\n~~~javascript\nErrorValue = {\n\tok: false,\t\t// Always set to \"false\".\n\terror: '',\t\t// Error message.\n\tcontext: '',\t// Context for the error (e.g. a function name).\n}\n~~~\n\n * \n\n**Value Coercion**\n\nAs data gets shuttled around between memory, files, and network transmissions, the representation of the data might\nchange to suit to the medium.\nFor example, an integer value being stored in a file might be read back out later as a string.\nIt's actual value hasn't changed, but the way it is represented has changed.\nJavascript can be pretty forgiving in these cases by allowing a certain amount of type fluidity;\nHowever, this can also cause some difficult to spot errors like when `'2' + 2` equals the string `'22'` and not the integer `4`.\n\nUse these functions the validate that a value's type is of an expected type and to coerce the value, in a common sense way,\nto that expected type.\n\n- `Types.Coerce( Value, Schema, ThrowErrors )`\n- `Types.Coerce( Value, Schema, ThrowErrors )`\n- `Types.Coerces( Values, Schemas, ThrowErrors )`\n\nThis tables describes how values are converted from one data type to another during coercion:\n\n| From Type | To Boolean     | To Number      | To String        | To Object      |\n|-----------|----------------|----------------|------------------|----------------|\n| undefined | DefaultValue() | DefaultValue() | DefaultValue()   | DefaultValue() |\n| null      | DefaultValue() | DefaultValue() | DefaultValue()   | DefaultValue() |\n| Boolean   | Value          | Number()       | toString()       | ErrorValue     |\n| Number    | Boolean()      | Value          | toString()       | ErrorValue     |\n| String    | Boolean()      | Number()       | Value            | JSON.parse()   |\n| Object    | Boolean()      | Number()       | JSON.stringify() | Value          |\n\n * \n\n**Related Reading**\n\n- [You Don't Know JS: Types & Grammar - Chapter 4. Coercion](https://www.oreilly.com/library/view/you-dont-know/9781491905159/ch04.html)\n\n * @todo Support extended number formats: positive-integer, negative-integer, positive-float, negative-float\n * @todo Support type: function\n * @todo Support format plugin-ins. Must implement: get_default(), is_type_of(value), can_coerce(type), coerce(value)\n*/\n//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\r\n\t\tHasValue: require( './001-Types.HasValue.js' )( Liquicode ).HasValue,\r\n\r\n\t\tCoerce: require( './010-Types.Coerce.js' )( Liquicode ).Coerce,\r\n\r\n\t\tFormats: require( './020-Types.Formats.js' )( Liquicode ).Formats,\r\n\t\tGetFormat: require( './021-Types.GetFormat.js' )( Liquicode ).GetFormat,\r\n\t\tIsFormat: require( './022-Types.IsFormat.js' )( Liquicode ).IsFormat,\r\n\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '001',\r\n\tmember_of: 'Types',\r\n\tname: 'HasValue',\r\n\ttype: 'function',\r\n\treturns: 'boolean',\r\n\treturns_description: 'True if Value actually contains a value.',\r\n\tsummary: 'Determine if a variable contains a value or or not.',\r\n\tdescription: `\r\nTests the provided Value parameter and returns false if it does not represent a value.\r\nMore specifically, if Value is undefined or null, then false is returned.\r\nif Value is a zero length string \\`\"\"\\` or an empty object \\`{}\\`, false is also returned.\r\nIn all other cases, this function returns true.\r\n`,\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: '*',\r\n\t\t\trequired: true,\r\n\t\t\tdescription: 'The value to test.',\r\n\t\t},\r\n\t},\r\n\ttodo: [],\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function HasValue\n\t * @returns {boolean}\n\t * True if Value actually contains a value.\n\t * @summary Determine if a variable contains a value or or not.\n\t * @description\n\t * \nTests the provided Value parameter and returns false if it does not represent a value.\nMore specifically, if Value is undefined or null, then false is returned.\nif Value is a zero length string `\"\"` or an empty object `{}`, false is also returned.\nIn all other cases, this function returns true.\n\n\t * @param {*} Value\n\t * The value to test.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction HasValue( Value )\r\n\t{\r\n\t\tif ( Value === undefined ) { return false; }\r\n\t\tif ( Value === null ) { return false; }\r\n\t\tif ( ( typeof Value === 'string' ) && ( Value.length === 0 ) ) { return false; }\r\n\t\tif ( ( typeof Value === 'object' ) && ( Object.keys( Value ).length === 0 ) ) { return false; }\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tHasValue: HasValue,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '010',\r\n\tmember_of: 'Types',\r\n\tname: 'Coerce',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\treturns_description: 'A \\`Coercion\\` object.',\r\n\tsummary: 'Returns a \\`Coercion\\` object which is used to coerce values to different types.',\r\n\tdescription: `\r\nThe returned \\`Coercion\\` object has a single member \\`Coercion.value\\` and a number of coercion functions:\r\n\r\n- \\`ToBoolean( Default = false )\\` :\r\n\tReturns the boolean value of \\`Coercion.value\\`.\r\n\tAnything can be coerced to a boolean.\r\n\tIf value is a string, then 'false' and '0' will return false while 'true' will return true.\r\n\r\n- \\`ToNumber( Default = 0 )\\` :\r\n\tReturns the numeric value of \\`Coercion.value\\`.\r\n\tBooleans, other numbers, and numeric strings can be coerced to a number.\r\n\r\n- \\`ToString( Default = '' )\\` :\r\n\tReturns the string value of \\`Coercion.value\\`.\r\n\tAnything can be coerced to a string.\r\n\tIf value is an object, then it is JSON stringified and returned.\r\n\r\n- \\`ToObject( Default = null )\\` :\r\n\tReturns the object value of \\`Coercion.value\\`.\r\n\tOnly JSON strings and other objects can be coerced to an object.\r\n\tIf value is a JSON string, then it is JSON parsed and returned.\r\n\r\n\\`Coercion.value\\` is set to the Value parameter.\r\n\r\n**Usage**\r\n\r\nThere are two ways to use the \\`Coercion\\` object.\r\n\r\nOne way is to immediately call one of the coercion functions after obtaining the \\`Coercion\\` object:\r\n~~~javascript\r\nlet number_42 = Liquicode.Types.Coerce( '42' ).ToNumber();\r\n~~~\r\n\r\nAnother way is to reuse the \\`Coercion\\` object and alter the \\`Coercion.value\\` property yourself:\r\n~~~javascript\r\nlet coercion = Liquicode.Types.Coerce();\r\ncoercion.value = '42';\r\nlet number_42 = coercion.ToNumber();\r\n~~~\r\n\r\n**Examples**\r\n\r\n~~~javascript\r\n// Coercing to boolean\r\nSchema.Coerce( null ).ToBoolean()           // = false\r\nSchema.Coerce( 0 ).ToBoolean()              // = false\r\nSchema.Coerce( 'true' ).ToBoolean()         // = true\r\n\r\n// Coercing to number\r\nSchema.Coerce( null ).ToNumber()            // = 0\r\nSchema.Coerce( '3.14' ).ToNumber()          // = 3.14\r\nSchema.Coerce( 'foo' ).ToNumber()           // = 0\r\n\r\n// Coercing to string\r\nSchema.Coerce( null ).ToString()            // = ''\r\nSchema.Coerce( '3.14' ).ToString()          // = '3.14'\r\nSchema.Coerce( { foo: 'bar' } ).ToString()  // = '{\"foo\":\"bar\"}'\r\n\r\n// Coercing to object\r\nSchema.Coerce( null ).ToObject()            // = null\r\nSchema.Coerce( 3.14 ).ToObject()            // = null\r\nSchema.Coerce( '{\"foo\":\"bar\"}' ).ToObject() // = { foo: 'bar' }\r\n\r\n// Coercing with a Default\r\nSchema.Coerce( 'Hello' ).ToNumber( -1 )     // = -1\r\nSchema.Coerce( true ).ToObject( {} )        // = {}\r\nSchema.Coerce( 1024 ).ToObject( {} )        // = {}\r\nSchema.Coerce( null ).ToObject( { a: 1 } )  // = { a: 1 }\r\nSchema.Coerce( null ).ToObject( [ 1, 2 ] )  // = [ 1, 2 ]\r\n~~~\r\n`,\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: '*',\r\n\t\t\trequired: false,\r\n\t\t\tdescription: 'The value to coerce. This value is set to \\`Coercion.value\\`.',\r\n\t\t},\r\n\t\tLoud: {\r\n\t\t\tname: 'Loud',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t\tdescription: 'Throws errors when set to `true`.',\r\n\t\t},\r\n\t},\r\n\ttodo: [],\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Coerce\n\t * @returns {object}\n\t * A `Coercion` object.\n\t * @summary Returns a `Coercion` object which is used to coerce values to different types.\n\t * @description\n\t * \nThe returned `Coercion` object has a single member `Coercion.value` and a number of coercion functions:\n\n- `ToBoolean( Default = false )` :\n\tReturns the boolean value of `Coercion.value`.\n\tAnything can be coerced to a boolean.\n\tIf value is a string, then 'false' and '0' will return false while 'true' will return true.\n\n- `ToNumber( Default = 0 )` :\n\tReturns the numeric value of `Coercion.value`.\n\tBooleans, other numbers, and numeric strings can be coerced to a number.\n\n- `ToString( Default = '' )` :\n\tReturns the string value of `Coercion.value`.\n\tAnything can be coerced to a string.\n\tIf value is an object, then it is JSON stringified and returned.\n\n- `ToObject( Default = null )` :\n\tReturns the object value of `Coercion.value`.\n\tOnly JSON strings and other objects can be coerced to an object.\n\tIf value is a JSON string, then it is JSON parsed and returned.\n\n`Coercion.value` is set to the Value parameter.\n\n**Usage**\n\nThere are two ways to use the `Coercion` object.\n\nOne way is to immediately call one of the coercion functions after obtaining the `Coercion` object:\n~~~javascript\nlet number_42 = Liquicode.Types.Coerce( '42' ).ToNumber();\n~~~\n\nAnother way is to reuse the `Coercion` object and alter the `Coercion.value` property yourself:\n~~~javascript\nlet coercion = Liquicode.Types.Coerce();\ncoercion.value = '42';\nlet number_42 = coercion.ToNumber();\n~~~\n\n**Examples**\n\n~~~javascript\n// Coercing to boolean\nSchema.Coerce( null ).ToBoolean()           // = false\nSchema.Coerce( 0 ).ToBoolean()              // = false\nSchema.Coerce( 'true' ).ToBoolean()         // = true\n\n// Coercing to number\nSchema.Coerce( null ).ToNumber()            // = 0\nSchema.Coerce( '3.14' ).ToNumber()          // = 3.14\nSchema.Coerce( 'foo' ).ToNumber()           // = 0\n\n// Coercing to string\nSchema.Coerce( null ).ToString()            // = ''\nSchema.Coerce( '3.14' ).ToString()          // = '3.14'\nSchema.Coerce( { foo: 'bar' } ).ToString()  // = '{\"foo\":\"bar\"}'\n\n// Coercing to object\nSchema.Coerce( null ).ToObject()            // = null\nSchema.Coerce( 3.14 ).ToObject()            // = null\nSchema.Coerce( '{\"foo\":\"bar\"}' ).ToObject() // = { foo: 'bar' }\n\n// Coercing with a Default\nSchema.Coerce( 'Hello' ).ToNumber( -1 )     // = -1\nSchema.Coerce( true ).ToObject( {} )        // = {}\nSchema.Coerce( 1024 ).ToObject( {} )        // = {}\nSchema.Coerce( null ).ToObject( { a: 1 } )  // = { a: 1 }\nSchema.Coerce( null ).ToObject( [ 1, 2 ] )  // = [ 1, 2 ]\n~~~\n\n\t * @param {*} [Value]\n\t * The value to coerce. This value is set to `Coercion.value`.\n\t * @param {boolean} [Loud]\n\t * Throws errors when set to `true`.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction default_or_error( Loud, Default, ErrorMessage )\r\n\t{\r\n\t\tif ( Loud ) { throw new Error( ErrorMessage ); }\r\n\t\treturn Default;\r\n\t}\r\n\r\n\r\n\tfunction Coerce( Value, Loud = false )\r\n\t{\r\n\t\treturn {\r\n\r\n\t\t\tvalue: Value,\r\n\t\t\tloud: Loud,\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tToBoolean: function ( Default = false )\r\n\t\t\t{\r\n\t\t\t\tif ( this.value === undefined ) { return Default; }\r\n\t\t\t\tif ( this.value === null ) { return Default; }\r\n\t\t\t\t// Special cases for strings.\r\n\t\t\t\tif ( typeof this.value === 'string' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( this.value === 'false' ) { return false; }\r\n\t\t\t\t\tif ( this.value === 'true' ) { return true; }\r\n\t\t\t\t\tif ( this.value === '0' ) { return false; }\r\n\t\t\t\t}\r\n\t\t\t\t// Coerce to Boolean.\r\n\t\t\t\tlet coerced = Boolean( this.value );\r\n\t\t\t\treturn coerced;\r\n\t\t\t},\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tToNumber: function ( Default = 0 )\r\n\t\t\t{\r\n\t\t\t\tif ( this.value === undefined ) { return Default; }\r\n\t\t\t\tif ( this.value === null ) { return Default; }\r\n\t\t\t\t// Coerce to Number.\r\n\t\t\t\tlet coerced = Number( this.value );\r\n\t\t\t\tif ( isNaN( coerced ) ) { return default_or_error( this.loud, Default, 'Unable to coerce value to a number.' ); }\r\n\t\t\t\t// throw new Error( `Value is not numeric.` );\r\n\t\t\t\treturn coerced;\r\n\t\t\t},\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tToString: function ( Default = '' )\r\n\t\t\t{\r\n\t\t\t\tif ( this.value === undefined ) { return Default; }\r\n\t\t\t\tif ( this.value === null ) { return Default; }\r\n\t\t\t\t// Special case for objects.\r\n\t\t\t\tif ( typeof this.value === 'object' )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn JSON.stringify( this.value );\r\n\t\t\t\t}\r\n\t\t\t\t// Coerce to String.\r\n\t\t\t\tif ( this.value.toString === undefined ) { return default_or_error( this.loud, Default, 'Unable to coerce value to a string.' ); }\r\n\t\t\t\tlet coerced = this.value.toString();\r\n\t\t\t\treturn coerced;\r\n\t\t\t},\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tToObject: function ( Default = null )\r\n\t\t\t{\r\n\t\t\t\tif ( this.value === undefined ) { return Default; }\r\n\t\t\t\tif ( this.value === null ) { return Default; }\r\n\t\t\t\t// Coerce to Object.\r\n\t\t\t\tswitch ( typeof this.value )\r\n\t\t\t\t{\r\n\t\t\t\t\t// case 'boolean': throw new Error( `Unable to ceorce from boolean to object.` );\r\n\t\t\t\t\tcase 'boolean': return default_or_error( this.loud, Default, 'Unable to coerce from boolean to object.' );\r\n\r\n\t\t\t\t\t// case 'number': throw new Error( `Unable to ceorce from number to object.` );\r\n\t\t\t\t\tcase 'number': return default_or_error( this.loud, Default, 'Unable to coerce from number to object.' );\r\n\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\tlet coerced = this.value.trim();\r\n\t\t\t\t\t\tif ( coerced.startsWith( '{' ) || coerced.startsWith( '[' ) )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcoerced = JSON.parse( coerced );\r\n\t\t\t\t\t\t\t\treturn coerced;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tcatch ( error )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn default_or_error( this.loud, Default, 'Unable to coerce from non-json string to object.' );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcase 'object': return this.value;\r\n\r\n\t\t\t\t\t// case 'function': throw new Error( `Unable to ceorce from function to object.` );\r\n\t\t\t\t\tcase 'function': return default_or_error( this.loud, Default, 'Unable to coerce from function to object.' );\r\n\r\n\t\t\t\t\t// case 'symbol': throw new Error( `Unable to ceorce from symbol to object.` );\r\n\t\t\t\t\tcase 'symbol': return default_or_error( this.loud, Default, 'Unable to coerce from symbol to object.' );\r\n\r\n\t\t\t\t\t// default: throw new Error( `Unknown type encountered [${typeof this.value}].` );\r\n\t\t\t\t\tdefault: return default_or_error( this.loud, Default, `Unknown type encountered [${typeof this.value}].` );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tToType: function ( TypeName, Default )\r\n\t\t\t{\r\n\t\t\t\tswitch ( TypeName )\r\n\t\t\t\t{\r\n\t\t\t\t\tcase 'boolean': return this.ToBoolean( Default );\r\n\t\t\t\t\tcase 'number': return this.ToNumber( Default );\r\n\t\t\t\t\tcase 'string': return this.ToString( Default );\r\n\t\t\t\t\tcase 'object': return this.ToObject( Default );\r\n\t\t\t\t\tdefault: throw new Error( `Invalid or unknown type name [${TypeName}].` );\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t};\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tCoerce: Coerce,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '020',\r\n\tmember_of: 'Types',\r\n\tname: 'Formats',\r\n\tsource_type: 'function',\r\n\treturns: 'object',\r\n\treturns_description: 'An array of \\`SchemaFormat\\` objects.',\r\n\tsummary: 'Returns an array of \\`SchemaFormat\\` objects used to convert values between different formats.',\r\n\tdescription: `\r\nReturns the library's internal array of format objects, \\`Types.Formats\\`.\r\n\r\nEach format has a \\`type\\` and \\`format\\` string, and an \\`IsFormat( Value )\\` function.\r\nThis list of formats is used by the \\`Types.GetFormat()\\` and \\`Types.IsFormat()\\` functions.\r\n\r\nApplications can ammend this array in order to customize type processing or add new formats.\r\nThe structure of each format in the array is:\r\n~~~javascript\r\n{\r\n\ttype: '',    // The Javascript data type. e.g. 'boolean', 'number', 'string', 'object'\r\n\tformat: '',  // A type specific format. e.g. 'integer', 'date'. \r\n\tIsFormat: function ( Value )\r\n\t{\r\n\t\treturn true;  // Return true, if Value is of this format.\r\n\t}\r\n}\r\n~~~\r\n\r\nFor example, here is the format object for \\`\"string:string\"\\`:\r\n~~~javascript\r\n{\r\n\ttype: 'string',\r\n\tformat: 'string',\r\n\tIsFormat: function ( Value )\r\n\t{\r\n\t\tif ( typeof Value !== 'string' ) { return false; }\r\n\t\treturn true;\r\n\t},\r\n},\r\n~~~\r\n\r\nYou have the ability to directly modify the \\`Types.Formats\\` array.\r\n\r\nFor example, suppose you want to define two new formats to detect objects of 'object:person' and 'object:employee'.\r\n~~~javascript\r\nPerson = {\r\n\tfirst_name: '',\r\n\tlast_name: '',\r\n}\r\nEmployee = {\r\n\tfirst_name: '',\r\n\tlast_name: '',\r\n\ttitle: '',\r\n}\r\n~~~\r\n\r\nThe format objects might look something like this:\r\n~~~javascript\r\nobject_person = {\r\n\ttype: 'object',\r\n\tformat: 'person',\r\n\tIsFormat: function( Value )\r\n\t{\r\n\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\tif ( !Value ) { return false; }\r\n\t\tif ( !Value.first_name ) { return false; }\r\n\t\tif ( !Value.last_name ) { return false; }\r\n\t\treturn true;\r\n\t},\r\n},\r\nobject_employee = {\r\n\ttype: 'object',\r\n\tformat: 'employee',\r\n\tIsFormat: function( Value )\r\n\t{\r\n\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\tif ( !Value ) { return false; }\r\n\t\tif ( !Value.first_name ) { return false; }\r\n\t\tif ( !Value.last_name ) { return false; }\r\n\t\tif ( !Value.title ) { return false; }\r\n\t\treturn true;\r\n\t},\r\n},\r\n~~~\r\n\r\nAnd tou can add them to the \\`Types.Formats\\` array:\r\n~~~javascript\r\nlet formats = Liquicode.Types.Formats();\r\nformats.push( object_person );\r\nformats.push( object_employee );\r\n~~~\r\n\r\nThe \\`Types.GetFormat()\\` function reads the formats array in reverse order when matching a value to a format.\r\nThis is done so that more complex types will not get \"short-circuited\" by less complex types.\r\nThe more complex format in this case is \"object:employee\" and should appear after \"object:person\" in the array.\r\n\r\n`,\r\n\tParameters: {},\r\n\ttodo: [],\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @name Formats\n\t * @returns {object}\n\t * An array of `SchemaFormat` objects.\n\t * @summary Returns an array of `SchemaFormat` objects used to convert values between different formats.\n\t * @description\n\t * \nReturns the library's internal array of format objects, `Types.Formats`.\n\nEach format has a `type` and `format` string, and an `IsFormat( Value )` function.\nThis list of formats is used by the `Types.GetFormat()` and `Types.IsFormat()` functions.\n\nApplications can ammend this array in order to customize type processing or add new formats.\nThe structure of each format in the array is:\n~~~javascript\n{\n\ttype: '',    // The Javascript data type. e.g. 'boolean', 'number', 'string', 'object'\n\tformat: '',  // A type specific format. e.g. 'integer', 'date'. \n\tIsFormat: function ( Value )\n\t{\n\t\treturn true;  // Return true, if Value is of this format.\n\t}\n}\n~~~\n\nFor example, here is the format object for `\"string:string\"`:\n~~~javascript\n{\n\ttype: 'string',\n\tformat: 'string',\n\tIsFormat: function ( Value )\n\t{\n\t\tif ( typeof Value !== 'string' ) { return false; }\n\t\treturn true;\n\t},\n},\n~~~\n\nYou have the ability to directly modify the `Types.Formats` array.\n\nFor example, suppose you want to define two new formats to detect objects of 'object:person' and 'object:employee'.\n~~~javascript\nPerson = {\n\tfirst_name: '',\n\tlast_name: '',\n}\nEmployee = {\n\tfirst_name: '',\n\tlast_name: '',\n\ttitle: '',\n}\n~~~\n\nThe format objects might look something like this:\n~~~javascript\nobject_person = {\n\ttype: 'object',\n\tformat: 'person',\n\tIsFormat: function( Value )\n\t{\n\t\tif ( typeof Value !== 'object' ) { return false; }\n\t\tif ( !Value ) { return false; }\n\t\tif ( !Value.first_name ) { return false; }\n\t\tif ( !Value.last_name ) { return false; }\n\t\treturn true;\n\t},\n},\nobject_employee = {\n\ttype: 'object',\n\tformat: 'employee',\n\tIsFormat: function( Value )\n\t{\n\t\tif ( typeof Value !== 'object' ) { return false; }\n\t\tif ( !Value ) { return false; }\n\t\tif ( !Value.first_name ) { return false; }\n\t\tif ( !Value.last_name ) { return false; }\n\t\tif ( !Value.title ) { return false; }\n\t\treturn true;\n\t},\n},\n~~~\n\nAnd tou can add them to the `Types.Formats` array:\n~~~javascript\nlet formats = Liquicode.Types.Formats();\nformats.push( object_person );\nformats.push( object_employee );\n~~~\n\nThe `Types.GetFormat()` function reads the formats array in reverse order when matching a value to a format.\nThis is done so that more complex types will not get \"short-circuited\" by less complex types.\nThe more complex format in this case is \"object:employee\" and should appear after \"object:person\" in the array.\n\n\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tlet _Formats = [\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// boolean : boolean\r\n\t\t{\r\n\t\t\ttype: 'boolean',\r\n\t\t\tformat: 'boolean',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'boolean' ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// number : number\r\n\t\t{\r\n\t\t\ttype: 'number',\r\n\t\t\tformat: 'number',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'number' ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// number : integer\r\n\t\t{\r\n\t\t\ttype: 'number',\r\n\t\t\tformat: 'integer',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'number' ) { return false; }\r\n\t\t\t\tif ( Value !== parseInt( Value.toString() ) ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// string : string\r\n\t\t{\r\n\t\t\ttype: 'string',\r\n\t\t\tformat: 'string',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'string' ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// string : json\r\n\t\t{\r\n\t\t\ttype: 'string',\r\n\t\t\tformat: 'json',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'string' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tValue = Value.trimStart();\r\n\t\t\t\tif ( !Value.startsWith( '{' ) && !Value.startsWith( '[' ) ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// string : datetime\r\n\t\t// 2005-05-01T00:00:00.000Z\r\n\t\t{\r\n\t\t\ttype: 'string',\r\n\t\t\tformat: 'datetime',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'string' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( Value.length !== 24 ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 0, 4 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 4 ] !== '-' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 5, 7 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 7 ] !== '-' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 8, 10 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 10 ] !== 'T' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 11, 13 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 13 ] !== ':' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 14, 16 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 16 ] !== ':' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 17, 19 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 19 ] !== '.' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 20, 23 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 23 ] !== 'Z' ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// string : date\r\n\t\t{\r\n\t\t\ttype: 'string',\r\n\t\t\tformat: 'date',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'string' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( Value.length !== 10 ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 0, 4 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 4 ] !== '-' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 5, 7 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 7 ] !== '-' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 8, 10 ) ) ) ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// string : time\r\n\t\t{\r\n\t\t\ttype: 'string',\r\n\t\t\tformat: 'time',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'string' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( Value.length !== 8 ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 0, 2 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 2 ] !== ':' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 3, 5 ) ) ) ) { return false; }\r\n\t\t\t\tif ( Value[ 5 ] !== ':' ) { return false; }\r\n\t\t\t\tif ( isNaN( Number( Value.substring( 6, 8 ) ) ) ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : object\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'object',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : datetime\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'datetime',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Value.getTime ) { return false; }\r\n\t\t\t\tif ( isNaN( Value.getTime() ) ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : array\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'array',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Array.isArray( Value ) ) { return false; }\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : boolean-array\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'boolean-array',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Array.isArray( Value ) ) { return false; }\r\n\t\t\t\tif ( !Value.length ) { return false; }\r\n\t\t\t\tfor ( let index = 0; index < Value.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( typeof Value[ index ] !== 'boolean' ) { return false; }\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : number-array\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'number-array',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Array.isArray( Value ) ) { return false; }\r\n\t\t\t\tif ( !Value.length ) { return false; }\r\n\t\t\t\tfor ( let index = 0; index < Value.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( typeof Value[ index ] !== 'number' ) { return false; }\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : string-array\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'string-array',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Array.isArray( Value ) ) { return false; }\r\n\t\t\t\tif ( !Value.length ) { return false; }\r\n\t\t\t\tfor ( let index = 0; index < Value.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( typeof Value[ index ] !== 'string' ) { return false; }\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : object-array\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'object-array',\r\n\t\t\t// target_type: 'object',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Array.isArray( Value ) ) { return false; }\r\n\t\t\t\tif ( !Value.length ) { return false; }\r\n\t\t\t\tfor ( let index = 0; index < Value.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( typeof Value[ index ] !== 'object' ) { return false; }\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// object : array-array\r\n\t\t{\r\n\t\t\ttype: 'object',\r\n\t\t\tformat: 'array-array',\r\n\t\t\ttarget_type: 'object',\r\n\t\t\tIsFormat: function ( Value )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Value !== 'object' ) { return false; }\r\n\t\t\t\tif ( !Value ) { return false; }\r\n\t\t\t\tif ( !Array.isArray( Value ) ) { return false; }\r\n\t\t\t\tif ( !Value.length ) { return false; }\r\n\t\t\t\tfor ( let index = 0; index < Value.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( typeof Value[ index ] !== 'object' ) { return false; }\r\n\t\t\t\t\tif ( !Array.isArray( Value[ index ] ) ) { return false; }\r\n\t\t\t\t}\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\t\t},\r\n\t];\r\n\r\n\r\n\tfunction Formats()\r\n\t{\r\n\t\treturn _Formats;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tFormats: Formats,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '021',\r\n\tmember_of: 'Types',\r\n\tname: 'GetFormat',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\treturns_description: 'An extended type description.',\r\n\tsummary: 'Determine the type and format of a value.',\r\n\tdescription: `\r\nIterates through \\`Types.Formats\\` in reverse order and calls each \\`Format.IsFormat()\\` function.\r\nWhen one of the formats returns \\`true\\`, then it's type and format are returned separated by \\`:\\`.\r\n\r\n**Examples**\r\n\r\n~~~javascript\r\nLiquicode.Types.GetFormat( '42' )         // = 'number:integer'\r\nLiquicode.Types.GetFormat( 'Hello' )      // = 'string:string'\r\nLiquicode.Types.GetFormat( new Date() )   // = 'object:datetime'\r\nLiquicode.Types.GetFormat( [ 1, 2, 3 ] )  // = 'object:number-array'\r\n~~~\r\n`,\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: '*',\r\n\t\t\trequired: true,\r\n\t\t\tdescription: 'The value to get the format for.',\r\n\t\t},\r\n\t},\r\n\ttodo: [],\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function GetFormat\n\t * @returns {string}\n\t * An extended type description.\n\t * @summary Determine the type and format of a value.\n\t * @description\n\t * \nIterates through `Types.Formats` in reverse order and calls each `Format.IsFormat()` function.\nWhen one of the formats returns `true`, then it's type and format are returned separated by `:`.\n\n**Examples**\n\n~~~javascript\nLiquicode.Types.GetFormat( '42' )         // = 'number:integer'\nLiquicode.Types.GetFormat( 'Hello' )      // = 'string:string'\nLiquicode.Types.GetFormat( new Date() )   // = 'object:datetime'\nLiquicode.Types.GetFormat( [ 1, 2, 3 ] )  // = 'object:number-array'\n~~~\n\n\t * @param {*} Value\n\t * The value to get the format for.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction GetFormat( Value )\r\n\t{\r\n\t\tlet formats = Liquicode.Types.Formats();\r\n\t\tfor ( let index = ( formats.length - 1 ); index >= 0; index-- )\r\n\t\t{\r\n\t\t\tlet format = formats[ index ];\r\n\t\t\tif ( format.IsFormat( Value ) )\r\n\t\t\t{\r\n\t\t\t\treturn `${format.type}:${format.format}`;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tGetFormat: GetFormat,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '022',\r\n\tmember_of: 'Types',\r\n\tname: 'IsFormat',\r\n\ttype: 'function',\r\n\treturns: 'boolean',\r\n\treturns_description: 'True if the value matches the format.',\r\n\tsummary: 'Determine if a value is of a particular format.',\r\n\tdescription: `\r\nLooks up the specified format in \\`Types.Formats\\` and calls the \\`Format.IsFormat()\\` function.\r\n\r\nThe \\`Format\\` parameter must specify both type and format to be tested for.\r\n\r\n**Examples**\r\n\r\n~~~javascript\r\nLiquicode.Types.IsFormat( 'Hello', 'string:string' )            // = true\r\nLiquicode.Types.IsFormat( 'Hello', 'string:json' )              // = false\r\nLiquicode.Types.IsFormat( [ 1, 2, 3 ], 'object:array' )         // = true\r\nLiquicode.Types.IsFormat( [ 1, 2, 3 ], 'object:number-array' )  // = true\r\nLiquicode.Types.IsFormat( [ 1, 2, 3 ], 'object:string-array' )  // = false\r\n~~~\r\n`,\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: '*',\r\n\t\t\trequired: true,\r\n\t\t\tdescription: 'The value to test.',\r\n\t\t},\r\n\t\tFormat: {\r\n\t\t\tname: 'Format',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdescription: 'The type and format to test for as: \\`\"type:format\"\\`.',\r\n\t\t\texamples:[\r\n\t\t\t\t'string:string',\r\n\t\t\t\t'string:json',\r\n\t\t\t\t'object:datetime',\r\n\t\t\t],\r\n\t\t},\r\n\t},\r\n\ttodo: [],\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function IsFormat\n\t * @returns {boolean}\n\t * True if the value matches the format.\n\t * @summary Determine if a value is of a particular format.\n\t * @description\n\t * \nLooks up the specified format in `Types.Formats` and calls the `Format.IsFormat()` function.\n\nThe `Format` parameter must specify both type and format to be tested for.\n\n**Examples**\n\n~~~javascript\nLiquicode.Types.IsFormat( 'Hello', 'string:string' )            // = true\nLiquicode.Types.IsFormat( 'Hello', 'string:json' )              // = false\nLiquicode.Types.IsFormat( [ 1, 2, 3 ], 'object:array' )         // = true\nLiquicode.Types.IsFormat( [ 1, 2, 3 ], 'object:number-array' )  // = true\nLiquicode.Types.IsFormat( [ 1, 2, 3 ], 'object:string-array' )  // = false\n~~~\n\n\t * @param {*} Value\n\t * The value to test.\n\t * @param {string} Format\n\t * The type and format to test for as: `\"type:format\"`.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction IsFormat( Value, Format )\r\n\t{\r\n\t\tlet formats = Liquicode.Types.Formats();\r\n\t\tfor ( let index = 0; index < formats.length; index++ )\r\n\t\t{\r\n\t\t\tlet format = formats[ index ];\r\n\t\t\tif ( Format === `${format.type}:${format.format}` )\r\n\t\t\t{\r\n\t\t\t\treturn format.IsFormat( Value );\r\n\t\t\t}\r\n\t\t}\r\n\t\tthrow new Error( `Unknown type and format [${Format}]. Should be of the form [type:format].` );\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tIsFormat: IsFormat,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '100',\r\n\tname: 'Object',\r\n\ttype: 'namespace',\r\n\tsummary: 'Functions for manipulating Javascript objects.',\r\n};\r\n\r\n\r\n//-start-jsdoc---------------------------------------------------------\r\n/**\n * @public\n * @namespace Object\n * @summary Functions for manipulating Javascript objects.\n*/\n//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\r\n\t\tClone: require( './101-Object.Clone.js' )( Liquicode ).Clone,\r\n\t\tMerge: require( './103-Object.Merge.js' )( Liquicode ).Merge,\r\n\t\t\r\n\t\t// Traverse: require( './110-Object.Traverse.js' )( Liquicode ).Traverse,\r\n\t\t// HasPath: require( './111-Object.HasPath.js' )( Liquicode ).HasPath,\r\n\t\t// FindField: require( './112-Object.FindField.js' )( Liquicode ).FindField,\r\n\t\t// FindValue: require( './113-Object.FindValue.js' )( Liquicode ).FindValue,\r\n\t\t// GetValue: require( './114-Object.GetValue.js' )( Liquicode ).GetValue,\r\n\t\t// SetValue: require( './115-Object.SetValue.js' )( Liquicode ).SetValue,\r\n\r\n\t\tFromJson: require( './120-Object.FromJson.js' )( Liquicode ).FromJson,\r\n\t\tToJsonOptions: require( './121-Object.ToJsonOptions.js' )( Liquicode ).ToJsonOptions,\r\n\t\tToJson: require( './122-Object.ToJson.js' )( Liquicode ).ToJson,\r\n\r\n\t\tFromIni: require( './125-Object.FromIni.js' )( Liquicode ).FromIni,\r\n\t\tToIni: require( './126-Object.ToIni.js' )( Liquicode ).ToIni,\r\n\r\n\t\t// ValueArrayOf: require( './130-Object.ValueArrayOf.js' )( Liquicode ).ValueArrayOf,\r\n\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '101',\r\n\tmember_of: 'Object',\r\n\tname: 'Clone',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Returns a clone of the given object.',\r\n\t\t'This is equivalent to doing A = JSON.parse( JSON.stringify( B ) ).',\r\n\t],\r\n\tParameters: {\r\n\t\tFrom: {\r\n\t\t\tname: 'From',\r\n\t\t\ttype: 'object',\r\n\t\t\t// required: true,\r\n\t\t\tdefault: {},\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Clone\n\t * @returns {string}\n\t * @description\n\t * Returns a clone of the given object.\n\t * This is equivalent to doing A = JSON.parse( JSON.stringify( B ) ).\n\t * @param {object} [From={}]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction Clone( From )\r\n\t{\r\n\t\t// From = Liquicode.Types.Coerce( From, _Schema.Parameters.From, { coerce_values: true, throw_errors: true } );\r\n\t\treturn JSON.parse( JSON.stringify( From ) );\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tClone: Clone,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '103',\r\n\tmember_of: 'Object',\r\n\tname: 'Merge',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: `\r\nMerges the content of two objects and returns the composite result.\r\n\r\nSimilar to Clone, this function will remove any non-data fields (i.e. functions and symbols) from the objects.\r\n`,\r\n\tParameters: {\r\n\t\tOriginal: {\r\n\t\t\tname: 'Original',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tUpdates: {\r\n\t\t\tname: 'Updates',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Merge\n\t * @returns {object}\n\t * @description\n\t * \nMerges the content of two objects and returns the composite result.\n\nSimilar to Clone, this function will remove any non-data fields (i.e. functions and symbols) from the objects.\n\n\t * @param {object} Original\n\t * @param {object} [Updates]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction Merge( Original, Updates )\r\n\t{\r\n\t\tOriginal = Liquicode.Types.Coerce( Original, true ).ToObject( {} );\r\n\t\tUpdates = Liquicode.Types.Coerce( Updates, true ).ToObject( {} );\r\n\r\n\t\tlet new_object = JSON.parse( JSON.stringify( Original ) );\r\n\r\n\t\tfunction update_children( ParentA, ParentB )\r\n\t\t{\r\n\t\t\tObject.keys( ParentB ).forEach(\r\n\t\t\t\tkey =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = ParentB[ key ];\r\n\t\t\t\t\tif ( ParentA[ key ] === undefined )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tParentA[ key ] = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( typeof value === 'object' )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Merge objects.\r\n\t\t\t\t\t\t\tif ( ( ParentA[ key ] === null ) && ( value === null ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Do nothing.\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if ( ( ParentA[ key ] !== null ) && ( value === null ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tParentA[ key ] = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if ( ( ParentA[ key ] === null ) && ( value !== null ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tParentA[ key ] = {};\r\n\t\t\t\t\t\t\t\tupdate_children( ParentA[ key ], value );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if ( ( ParentA[ key ] !== null ) && ( value !== null ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tupdate_children( ParentA[ key ], value );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Overwrite values.\r\n\t\t\t\t\t\t\tParentA[ key ] = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} );\r\n\t\t}\r\n\r\n\t\tupdate_children( new_object, Updates );\r\n\t\treturn new_object;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tMerge: Merge,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '120',\r\n\tmember_of: 'Object',\r\n\tname: 'FromJson',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: `\r\nParse a Json string and return an object value.\r\nThis is identical Javascript's \"JSON.parse()\" function.\r\n\r\nThere are some significant differences from Javascript's version.\r\nThe parser is a bit more relaxed and allows:\r\n- Identifiers are not required to have quotes.\r\n- A comma can appear after the last element of an array or object.\r\n- String literals can use either single or double quotes.\r\n- Parsing automatically stops when the closing brace or bracket is found in the json string.\r\n\r\n`,\r\n\tParameters: {\r\n\t\tJsonString: {\r\n\t\t\tname: 'JsonString',\r\n\t\t\ttype: 'string',\r\n\t\t\t// required: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function FromJson\n\t * @returns {object}\n\t * @description\n\t * \nParse a Json string and return an object value.\nThis is identical Javascript's \"JSON.parse()\" function.\n\nThere are some significant differences from Javascript's version.\nThe parser is a bit more relaxed and allows:\n- Identifiers are not required to have quotes.\n- A comma can appear after the last element of an array or object.\n- String literals can use either single or double quotes.\n- Parsing automatically stops when the closing brace or bracket is found in the json string.\n\n\n\t * @param {string} [JsonString]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction FromJson( JsonString )\r\n\t{\r\n\t\t// JsonString = Liquicode.Types.Coerce( JsonString, _Schema.Parameters.JsonString, true );\r\n\t\tJsonString = JsonString || '';\r\n\t\tif ( typeof JsonString !== 'string' ) { JsonString = JsonString.toString(); }\r\n\r\n\t\tlet tokens = Tokenize( JsonString );\r\n\t\treturn BuildObject( tokens );\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction Tokenize( Json )\r\n\t{\r\n\t\tlet tokens = [];\r\n\r\n\t\t// Json = Json.replace( '\\t', ' ' );\r\n\t\t// Json = Json.replace( '\\n', ' ' );\r\n\t\t// while ( Json.includes( '  ' ) ) { Json = Json.replace( '  ', ' ' ); }\r\n\r\n\t\tlet whitespace = ' \\t\\n';\r\n\t\tlet delimiters = '[]{}:,';\r\n\t\tlet quotes = `'\"`;\r\n\r\n\t\tlet ichar = 0;\r\n\t\twhile ( ichar < Json.length )\r\n\t\t{\r\n\t\t\tlet ch = Json.charAt( ichar );\r\n\t\t\tif ( whitespace.includes( ch ) )\r\n\t\t\t{\r\n\t\t\t\tichar++;\r\n\t\t\t}\r\n\t\t\telse if ( delimiters.includes( ch ) )\r\n\t\t\t{\r\n\t\t\t\ttokens.push( {\r\n\t\t\t\t\ttoken: ch,\r\n\t\t\t\t\ttype: 'delimiter',\r\n\t\t\t\t\tat: ichar,\r\n\t\t\t\t} );\r\n\t\t\t\tichar++;\r\n\t\t\t}\r\n\t\t\telse if ( quotes.includes( ch ) )\r\n\t\t\t{\r\n\t\t\t\tlet iat = ichar;\r\n\t\t\t\tichar++;\r\n\t\t\t\tlet s = '';\r\n\t\t\t\twhile ( ichar < Json.length )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet ch2 = Json.charAt( ichar );\r\n\t\t\t\t\tif ( ch2 === ch )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tichar++;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ch2 === '\\\\' )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tichar++;\r\n\t\t\t\t\t\tif ( ichar < Json.length )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tch2 = Json.charAt( ichar );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tch2 = '';\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\ts += ch2;\r\n\t\t\t\t\tichar++;\r\n\t\t\t\t}\r\n\t\t\t\ttokens.push( {\r\n\t\t\t\t\ttoken: s,\r\n\t\t\t\t\ttype: 'string',\r\n\t\t\t\t\tat: iat,\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlet iat = ichar;\r\n\t\t\t\tichar++;\r\n\t\t\t\tlet s = ch;\r\n\t\t\t\twhile ( ichar < Json.length )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet ch2 = Json.charAt( ichar );\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\twhitespace.includes( ch2 )\r\n\t\t\t\t\t\t|| delimiters.includes( ch2 )\r\n\t\t\t\t\t\t|| quotes.includes( ch2 )\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ts += ch2;\r\n\t\t\t\t\tichar++;\r\n\t\t\t\t}\r\n\t\t\t\ttokens.push( {\r\n\t\t\t\t\ttoken: s,\r\n\t\t\t\t\ttype: 'literal',\r\n\t\t\t\t\tat: iat,\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction BuildObject( Tokens )\r\n\t{\r\n\t\twhile ( Tokens.length )\r\n\t\t{\r\n\t\t\tif ( Tokens[ 0 ].token === '[' )\r\n\t\t\t{\r\n\t\t\t\tTokens.shift();\r\n\t\t\t\tlet value = [];\r\n\t\t\t\twhile ( Tokens[ 0 ].token !== ']' )\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue.push( BuildObject( Tokens ) );\r\n\t\t\t\t}\r\n\t\t\t\tTokens.shift();\r\n\t\t\t\tconsume_comma( Tokens );\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\telse if ( Tokens[ 0 ].token === '{' )\r\n\t\t\t{\r\n\t\t\t\tTokens.shift();\r\n\t\t\t\tlet value = {};\r\n\t\t\t\twhile ( Tokens[ 0 ].token !== '}' )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet key = Tokens.shift();\r\n\t\t\t\t\tlet colon = Tokens.shift();\r\n\t\t\t\t\tif ( ( key.type !== 'literal' ) && ( key.type !== 'string' ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new Error( `At position [${key.at}]: Expected literal, found ${key.type} '${key.token}' instead.`, key );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( colon.token !== ':' )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new Error( `At position [${colon.at}]: Expected ':', found '${colon.token}' instead.`, colon );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalue[ key.token ] = BuildObject( Tokens );\r\n\t\t\t\t}\r\n\t\t\t\tTokens.shift();\r\n\t\t\t\tconsume_comma( Tokens );\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tlet value = Tokens[ 0 ].token;\r\n\t\t\t\tif ( Tokens[ 0 ].type === 'literal' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( value.toLowerCase() === 'null' )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( value.toLowerCase() === 'true' )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( value.toLowerCase() === 'false' )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = false;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( !isNaN( parseFloat( value ) ) && isFinite( value ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = parseFloat( value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tTokens.shift();\r\n\t\t\t\tconsume_comma( Tokens );\r\n\t\t\t\treturn value;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction consume_comma( Tokens )\r\n\t{\r\n\t\tif ( !Tokens.length ) { return; }\r\n\t\tif ( Tokens[ 0 ].token === ',' ) \r\n\t\t{\r\n\t\t\tTokens.shift();\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tFromJson: FromJson,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '121',\r\n\tmember_of: 'Object',\r\n\tname: 'ToJsonOptions',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: `\r\n`,\r\n\tParameters: {\r\n\t\tPresetName: {\r\n\t\t\tname: 'PresetName',\r\n\t\t\ttype: 'string',\r\n\t\t\t// required: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ToJsonOptions\n\t * @returns {object}\n\t * @description\n\t * \n\n\t * @param {string} [PresetName]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ToJsonOptions( PresetName )\r\n\t{\r\n\t\tPresetName = Liquicode.Types.Coerce( PresetName ).ToString();\r\n\r\n\t\tlet options = {\r\n\t\t\tidentifier_quote: `\"`,\r\n\t\t\tliteral_quote: `\"`,\r\n\t\t\talways_quote_identifiers: true,\t// Implemented?\r\n\t\t\teol_char: '',\r\n\t\t\ttab_char: '',\r\n\t\t\tspace_char: '',\r\n\t\t\tliberal_commas: false,\r\n\t\t\talign_values: false,\r\n\t\t\t//TODO: The following options have not been implemented:\r\n\t\t\t// extroverted_arrays: true,\r\n\t\t\t// extroverted_brackets: true,\r\n\t\t\t// extroverted_braces: true,\r\n\t\t};\r\n\t\tif ( !PresetName || PresetName === 'default' )\r\n\t\t{\r\n\t\t\t/* Do Nothing */\r\n\t\t}\r\n\t\telse if ( PresetName === 'pretty' )\r\n\t\t{\r\n\t\t\toptions.identifier_quote = `\"`;\r\n\t\t\toptions.literal_quote = `\"`;\r\n\t\t\toptions.always_quote_identifiers = true;\r\n\t\t\toptions.eol_char = '\\n';\r\n\t\t\toptions.tab_char = '    ';\r\n\t\t\toptions.space_char = ' ';\r\n\t\t}\r\n\t\telse if ( PresetName === 'pretty-2' )\r\n\t\t{\r\n\t\t\toptions.identifier_quote = `'`;\r\n\t\t\toptions.literal_quote = `\"`;\r\n\t\t\toptions.always_quote_identifiers = false;\r\n\t\t\toptions.eol_char = '\\n';\r\n\t\t\toptions.tab_char = '    ';\r\n\t\t\toptions.space_char = ' ';\r\n\t\t\toptions.liberal_commas = true;\r\n\t\t\toptions.align_values = true;\r\n\t\t\t// options.extroverted_arrays = true;\r\n\t\t\t// options.extroverted_brackets = true;\r\n\t\t\t// options.extroverted_braces = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new Error( `The parameter [PresetName] has an invalid value of [${PresetName}]. Must be one of: 'default', 'pretty', or 'pretty-2'.` );\r\n\t\t}\r\n\t\treturn options;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tToJsonOptions: ToJsonOptions,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '122',\r\n\tmember_of: 'Object',\r\n\tname: 'ToJson',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: `\r\n`,\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: '*',\r\n\t\t\tdescription: `The value to convert to a json string.`,\r\n\t\t},\r\n\t\tJsonOptions: {\r\n\t\t\tname: 'JsonOptions',\r\n\t\t\ttype: 'object|string',\r\n\t\t\tdescription: `Can be an options object or the name of an options preset (\"default\", \"pretty\", or \"pretty-2\")`,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ToJson\n\t * @returns {object}\n\t * @description\n\t * \n\n\t * @param {*} [Value]\n\t * The value to convert to a json string.\n\t * @param {object|string} [JsonOptions]\n\t * Can be an options object or the name of an options preset (\"default\", \"pretty\", or \"pretty-2\")\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ToJson( Value, JsonOptions )\r\n\t{\r\n\t\tlet options = Liquicode.Object.ToJsonOptions();\r\n\t\tif ( typeof JsonOptions === 'string' )\r\n\t\t{\r\n\t\t\toptions = Liquicode.Object.ToJsonOptions( JsonOptions );\r\n\t\t}\r\n\t\telse if ( ( typeof JsonOptions === 'object' ) && Object.keys( JsonOptions ).length )\r\n\t\t{\r\n\t\t\toptions = Liquicode.Object.Merge( options, JsonOptions );\r\n\t\t}\r\n\r\n\t\treturn stringify_recurse( Value, 0, options );\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction stringify_recurse( Node, Depth, Options, Context = null )\r\n\t{\r\n\t\tlet text = '';\r\n\r\n\t\tif ( typeof Node === 'undefined' )\r\n\t\t{\r\n\t\t\t// return '';\r\n\t\t}\r\n\t\telse if ( typeof Node === 'boolean' )\r\n\t\t{\r\n\t\t\ttext += Node.toString();\r\n\t\t}\r\n\t\telse if ( typeof Node === 'number' )\r\n\t\t{\r\n\t\t\ttext += Node.toString();\r\n\t\t}\r\n\t\telse if ( typeof Node === 'bigint' )\r\n\t\t{\r\n\t\t\ttext += Node.toString();\r\n\t\t}\r\n\t\telse if ( typeof Node === 'string' )\r\n\t\t{\r\n\t\t\tlet value = Node.toString();\r\n\t\t\tif ( Options.literal_quote )\r\n\t\t\t{\r\n\t\t\t\tvalue = value.replace( Options.literal_quote, '\\\\' + Options.literal_quote );\r\n\t\t\t}\r\n\t\t\ttext += `${Options.literal_quote}${value}${Options.literal_quote}`;\r\n\t\t}\r\n\t\telse if ( typeof Node === 'symbol' )\r\n\t\t{\r\n\t\t\t// return '';\r\n\t\t}\r\n\t\telse if ( typeof Node === 'function' )\r\n\t\t{\r\n\t\t\t// return '';\r\n\t\t}\r\n\t\telse if ( typeof Node === 'object' )\r\n\t\t{\r\n\t\t\tif ( Node === null )\r\n\t\t\t{\r\n\t\t\t\ttext += 'null';\r\n\t\t\t}\r\n\t\t\telse if ( Array.isArray( Node ) )\r\n\t\t\t{\r\n\t\t\t\ttext += Options.eol_char;\r\n\t\t\t\ttext += Options.tab_char.repeat( Depth );\r\n\t\t\t\ttext += '[' + Options.space_char;\r\n\t\t\t\ttext += Options.eol_char;\r\n\t\t\t\tfor ( let index = 0; index < Node.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\ttext += Options.tab_char.repeat( Depth + 1 );\r\n\t\t\t\t\ttext += stringify_recurse( Node[ index ], Depth + 1, Options, 'array-element' );\r\n\t\t\t\t\tif ( ( index < ( Node.length - 1 ) ) || Options.liberal_commas )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttext += ',' + Options.space_char;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttext += Options.eol_char;\r\n\t\t\t\t}\r\n\t\t\t\ttext += Options.tab_char.repeat( Depth );\r\n\t\t\t\tif ( !Options.eol_char ) { text += Options.space_char; }\r\n\t\t\t\ttext += ']';\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( Context === 'field-value' )\r\n\t\t\t\t{\r\n\t\t\t\t\ttext += Options.eol_char;\r\n\t\t\t\t\ttext += Options.tab_char.repeat( Depth );\r\n\t\t\t\t}\r\n\t\t\t\ttext += '{' + Options.space_char;\r\n\t\t\t\ttext += Options.eol_char;\r\n\t\t\t\tlet keys = Object.keys( Node );\r\n\t\t\t\tlet max_key_length = 0;\r\n\t\t\t\tkeys.map( ( key ) => { if ( key.length > max_key_length ) { max_key_length = key.length; } } );\r\n\t\t\t\tfor ( let index = 0; index < keys.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet key = keys[ index ];\r\n\t\t\t\t\ttext += Options.tab_char.repeat( Depth + 1 );\r\n\t\t\t\t\t//TODO: Implement: Options.always_quote_identifiers = false\r\n\t\t\t\t\ttext += `${Options.identifier_quote}${key}${Options.identifier_quote}`;\r\n\t\t\t\t\ttext += ':';\r\n\t\t\t\t\tif ( Options.align_values )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttext += ' '.repeat( max_key_length - key.length );\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttext += Options.space_char;\r\n\t\t\t\t\ttext += stringify_recurse( Node[ key ], Depth + 1, Options, 'field-value' );\r\n\t\t\t\t\tif ( ( index < ( keys.length - 1 ) ) || Options.liberal_commas )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttext += ',' + Options.space_char;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttext += Options.eol_char;\r\n\t\t\t\t}\r\n\t\t\t\ttext += Options.tab_char.repeat( Depth );\r\n\t\t\t\tif ( !Options.eol_char ) { text += Options.space_char; }\r\n\t\t\t\ttext += '}';\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn text;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tToJson: ToJson,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '125',\r\n\tmember_of: 'Object',\r\n\tname: 'FromIni',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: `\r\nParse an Ini string and return an object value.\r\n\r\n`,\r\n\tParameters: {\r\n\t\tIniString: {\r\n\t\t\tname: 'IniString',\r\n\t\t\ttype: 'string',\r\n\t\t\t// required: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function FromIni\n\t * @returns {object}\n\t * @description\n\t * \nParse an Ini string and return an object value.\n\n\n\t * @param {string} [IniString]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction FromIni( IniString )\r\n\t{\r\n\t\tIniString = Liquicode.Types.Coerce( IniString ).ToString();\r\n\r\n\t\t//NOTE: This function has the following side effects:\r\n\t\t//\t\t- ignores all lines before the first section is found\r\n\t\t//\t\t- ignores all entry lines which do not contain an '=' character\r\n\t\t//\t\t- All entry values are stored as strings and no conversion is attempted\r\n\t\tlet object_value = {};\r\n\t\tlet lines = IniString.split( '\\n' );\r\n\t\tlet section_name = '';\r\n\t\tfor ( let line_index = 0; line_index < lines.length; line_index++ )\r\n\t\t{\r\n\t\t\tlet line = lines[ line_index ];\r\n\t\t\tif ( !line ) { continue; }\r\n\t\t\tline = line.trim();\r\n\t\t\tif ( line.startsWith( '[' ) )\r\n\t\t\t{\r\n\t\t\t\t// New Section\r\n\t\t\t\tlet ich = line.indexOf( ']' );\r\n\t\t\t\tif ( ich < 0 ) { ich = line.length; }\r\n\t\t\t\tsection_name = line.substring( 1, ich );\r\n\t\t\t\tsection_name = section_name.trim();\r\n\t\t\t\tobject_value[ section_name ] = {};\r\n\t\t\t}\r\n\t\t\telse if ( section_name )\r\n\t\t\t{\r\n\t\t\t\t// New Entry\r\n\t\t\t\tlet ich = line.indexOf( '=' );\r\n\t\t\t\tif ( ich < 0 ) { continue; }\r\n\t\t\t\tlet entry_name = line.substring( 0, ich );\r\n\t\t\t\tentry_name = entry_name.trim();\r\n\t\t\t\tlet entry_value = line.substring( ich + 1 );\r\n\t\t\t\tentry_value = entry_value.trim();\r\n\t\t\t\tobject_value[ section_name ][ entry_name ] = entry_value;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn object_value;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tFromIni: FromIni,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '126',\r\n\tmember_of: 'Object',\r\n\tname: 'ToIni',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: `\r\nParse an Ini string and return an object value.\r\n\r\n`,\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: 'object',\r\n\t\t\t// required: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ToIni\n\t * @returns {object}\n\t * @description\n\t * \nParse an Ini string and return an object value.\n\n\n\t * @param {object} [Value]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ToIni( Value )\r\n\t{\r\n\t\tValue = Liquicode.Types.Coerce( Value ).ToObject();\r\n\r\n\t\t//NOTE: This function has the following side effects:\r\n\t\t//\t\t- ignores all sections that are not of type object\r\n\t\t//\t\t- ignores all entry values that are not of a primitive type\r\n\t\tlet ini_text = '';\r\n\t\tlet section_keys = Object.keys( Value );\r\n\t\tfor ( let section_index = 0; section_index < section_keys.length; section_index++ )\r\n\t\t{\r\n\t\t\tlet section_key = section_keys[ section_index ];\r\n\t\t\tlet section_data = Value[ section_key ];\r\n\t\t\tif ( !( typeof section_data === 'object' ) ) { continue; }\r\n\t\t\tif ( Array.isArray( section_data ) ) { continue; }\r\n\t\t\tini_text += `[${section_key}]\\n`;\r\n\t\t\tlet entry_keys = Object.keys( section_data );\r\n\t\t\tfor ( let entry_index = 0; entry_index < entry_keys.length; entry_index++ )\r\n\t\t\t{\r\n\t\t\t\tlet entry_key = entry_keys[ entry_index ];\r\n\t\t\t\tlet entry_value = section_data[ entry_key ];\r\n\t\t\t\tif (\r\n\t\t\t\t\t( typeof entry_value === 'symbol' )\r\n\t\t\t\t\t|| ( typeof entry_value === 'function' )\r\n\t\t\t\t\t|| ( typeof entry_value === 'object' )\r\n\t\t\t\t)\r\n\t\t\t\t{\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tini_text += `${entry_key}=${entry_value}\\n`;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ini_text;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tToIni: ToIni,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '200',\r\n\tname: 'Text',\r\n\ttype: 'namespace',\r\n\tsummary: 'Functions for text parsing and manipulation.',\r\n};\r\n\r\n\r\n//-start-jsdoc---------------------------------------------------------\r\n/**\n * @public\n * @namespace Text\n * @summary Functions for text parsing and manipulation.\n*/\n//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\r\n\t\tCompare: require( './202-Text.Compare.js' )( Liquicode ).Compare,\r\n\t\tMatches: require( './203-Text.Matches.js' )( Liquicode ).Matches,\r\n\r\n\t\tReplaceCharacters: require( './210-Text.ReplaceCharacters.js' )( Liquicode ).ReplaceCharacters,\r\n\t\tReplaceText: require( './211-Text.ReplaceText.js' )( Liquicode ).ReplaceText,\r\n\t\tFindBetween: require( './213-Text.FindBetween.js' )( Liquicode ).FindBetween,\r\n\t\tReplaceBetween: require( './214-Text.ReplaceBetween.js' )( Liquicode ).ReplaceBetween,\r\n\r\n\t\tFirstWord: require( './220-Text.FirstWord.js' )( Liquicode ).FirstWord,\r\n\t\tAfterFirstWord: require( './221-Text.AfterFirstWord.js' )( Liquicode ).AfterFirstWord,\r\n\t\tLastWord: require( './222-Text.LastWord.js' )( Liquicode ).LastWord,\r\n\t\tBeforeLastWord: require( './223-Text.BeforeLastWord.js' )( Liquicode ).BeforeLastWord,\r\n\t};\r\n};\r\n\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '201',\r\n\tmember_of: 'Text',\r\n\tname: 'Compare',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Compares two strings.',\r\n\t\t'Returns a `-1` if `StringA` is less than `StringB`.',\r\n\t\t'Returns a `1` if `StringA` is greater than than `StringB`.',\r\n\t\t'Returns a `0` if `StringA` and `StringB` are the same.',\r\n\t],\r\n\tParameters: {\r\n\t\tStringA: {\r\n\t\t\tname: 'StringA',\r\n\t\t\ttype: 'string',\r\n\t\t\t// required: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tStringB: {\r\n\t\t\tname: 'StringB',\r\n\t\t\ttype: 'string',\r\n\t\t\t// required: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tCaseSensitive: {\r\n\t\t\tname: 'CaseSensitive',\r\n\t\t\ttype: 'boolean',\r\n\t\t\t// required: true,\r\n\t\t\tdefault: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Compare\n\t * @returns {string}\n\t * @description\n\t * Compares two strings.\n\t * Returns a `-1` if `StringA` is less than `StringB`.\n\t * Returns a `1` if `StringA` is greater than than `StringB`.\n\t * Returns a `0` if `StringA` and `StringB` are the same.\n\t * @param {string} [StringA]\n\t * @param {string} [StringB]\n\t * @param {boolean} [CaseSensitive=true]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction Compare( StringA, StringB, CaseSensitive )\r\n\t{\r\n\t\tStringA = Liquicode.Types.Coerce( StringA, _Schema.Parameters.StringA , { coerce_values: true, throw_errors: true });\r\n\t\tStringB = Liquicode.Types.Coerce( StringB, _Schema.Parameters.StringB , { coerce_values: true, throw_errors: true });\r\n\t\tCaseSensitive = Liquicode.Types.Coerce( CaseSensitive, _Schema.Parameters.CaseSensitive, { coerce_values: true, throw_errors: true } );\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif ( typeof StringA !== 'string' ) { return -1; }\r\n\t\t\tif ( typeof StringB !== 'string' ) { return 1; }\r\n\t\t\tif ( !CaseSensitive )\r\n\t\t\t{\r\n\t\t\t\tStringA = StringA.toLowerCase();\r\n\t\t\t\tStringB = StringB.toLowerCase();\r\n\t\t\t}\r\n\t\t\treturn StringA.localeCompare( StringB );\r\n\t\t}\r\n\t\tcatch ( error ) \r\n\t\t{\r\n\t\t\tconsole.error( error.message, error );\r\n\t\t\treturn null;\r\n\t\t}\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tCompare: Compare,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '203',\r\n\tmember_of: 'Text',\r\n\tname: 'Matches',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Matches the text against a wildcard-lik pattern.',\r\n\t\t'Returns true If the match succeeds, otherwise false.',\r\n\t],\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'Text',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tPattern: {\r\n\t\t\tname: 'Pattern',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Matches\n\t * @returns {string}\n\t * @description\n\t * Matches the text against a wildcard-lik pattern.\n\t * Returns true If the match succeeds, otherwise false.\n\t * @param {string} Text\n\t * @param {string} Pattern\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction Matches( Text, Pattern ) \r\n\t{\r\n\t\t// Validate Parameters\r\n\t\tText = Liquicode.Types.Coerce( Text ).ToString();\r\n\t\tPattern = Liquicode.Types.Coerce( Pattern ).ToString();\r\n\r\n\t\t//FROM: https://stackoverflow.com/a/57527468\r\n\t\tlet wildcard_exp = Pattern.replace( /[.+^${}()|[\\]\\\\]/g, '\\\\$&' ); // regexp escape \r\n\t\tlet reg_exp = new RegExp( `^${wildcard_exp.replace( /\\*/g, '.*' ).replace( /\\?/g, '.' )}$`, 'i' );\r\n\t\treturn reg_exp.test( Text ); // remove last 'i' above to have case sensitive\r\n\t}\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tMatches: Matches,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '210',\r\n\tmember_of: 'Text',\r\n\tname: 'ReplaceCharacters',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Replaces characters within a string.',\r\n\t\t'Returns the modified string.',\r\n\t],\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'Text',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tSearchCharacters: {\r\n\t\t\tname: 'SearchCharacters',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tReplacementText: {\r\n\t\t\tname: 'ReplacementText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tMaxTimes: {\r\n\t\t\tname: 'MaxTimes',\r\n\t\t\ttype: 'number',\r\n\t\t\tformat: 'integer',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: -1,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ReplaceCharacters\n\t * @returns {string}\n\t * @description\n\t * Replaces characters within a string.\n\t * Returns the modified string.\n\t * @param {string} Text\n\t * @param {string} SearchCharacters\n\t * @param {string} ReplacementText\n\t * @param {number} [MaxTimes=-1]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ReplaceCharacters( Text, SearchCharacters, ReplacementText, MaxTimes )\r\n\t{\r\n\t\t// Validate Parameters\r\n\t\tText = Liquicode.Types.Coerce( Text ).ToString();\r\n\t\tSearchCharacters = Liquicode.Types.Coerce( SearchCharacters ).ToString();\r\n\t\tReplacementText = Liquicode.Types.Coerce( ReplacementText ).ToString();\r\n\t\tMaxTimes = Liquicode.Types.Coerce( MaxTimes ).ToNumber();\r\n\r\n\t\tlet new_text = '';\r\n\t\tlet count = 0;\r\n\t\tfor ( let index = 0; index < Text.length; index++ )\r\n\t\t{\r\n\t\t\tif ( ( MaxTimes > 0 ) && ( count >= MaxTimes ) ) \r\n\t\t\t{\r\n\t\t\t\tnew_text += Text.slice( index );\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\tlet char = Text[ index ];\r\n\t\t\tif ( SearchCharacters.indexOf( char ) >= 0 )\r\n\t\t\t{\r\n\t\t\t\tchar = ReplacementText;\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\tnew_text += char;\r\n\t\t}\r\n\t\treturn new_text;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tReplaceCharacters: ReplaceCharacters,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '211',\r\n\tmember_of: 'Text',\r\n\tname: 'ReplaceText',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: ``,\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'Text',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tSearchText: {\r\n\t\t\tname: 'SearchText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tReplacementText: {\r\n\t\t\tname: 'ReplacementText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tMaxTimes: {\r\n\t\t\tname: 'MaxTimes',\r\n\t\t\ttype: 'number',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: 1,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ReplaceText\n\t * @returns {string}\n\t * @param {string} Text\n\t * @param {string} SearchText\n\t * @param {string} ReplacementText\n\t * @param {number} [MaxTimes=1]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ReplaceText( Text, SearchText, ReplacementText, MaxTimes ) \r\n\t{\r\n\t\t// // Validate Parameters\r\n\t\t// Text = Liquicode.Types.Coerce( Text ).ToString();\r\n\t\t// SearchText = Liquicode.Types.Coerce( SearchText ).ToString();\r\n\t\t// ReplacementText = Liquicode.Types.Coerce( ReplacementText ).ToString();\r\n\t\t// return Text.split( SearchText ).join( ReplacementText );\r\n\r\n\t\tif ( typeof Text !== 'string' ) { throw new Error( `The parameter [Text] is required and must be a string.` ); }\r\n\t\tif ( typeof SearchText !== 'string' ) { throw new Error( `The parameter [SearchText] is required and must be a string.` ); }\r\n\t\tif ( typeof ReplacementText !== 'string' ) { throw new Error( `The parameter [ReplacementText] is required and must be a string.` ); }\r\n\t\tif ( MaxTimes === undefined ) { MaxTimes = 1; }\r\n\t\tif ( typeof MaxTimes !== 'number' ) { throw new Error( `The parameter [MaxTimes] is optional but must be a number.` ); }\r\n\r\n\t\tlet text = Text;\r\n\t\tlet replacement_count = 0;\r\n\t\twhile ( true )\r\n\t\t{\r\n\t\t\tif ( ( MaxTimes >= 0 ) && ( replacement_count >= MaxTimes ) ) { break; }\r\n\t\t\tlet found_index = text.indexOf( SearchText );\r\n\t\t\tif ( found_index < 0 ) { break; }\r\n\t\t\ttext = `${text.substring( 0, found_index )}${ReplacementText}${text.substring( found_index + SearchText.length )}`;\r\n\t\t\treplacement_count++;\r\n\t\t}\r\n\r\n\t\treturn text;\r\n\t}\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tReplaceText: ReplaceText,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '213',\r\n\tmember_of: 'Text',\r\n\tname: 'FindBetween',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\treturns_description: 'The text found between StartText and EndText.',\r\n\tsummary: 'Search a string and return the text found between StartText and EndText.',\r\n\tdescription: `\r\nThis function searches a string for StartText and EndText and returns all text found between the two.\r\n\r\nIf StartText is missing, then the search will return all text up to the found EndText.\r\n\r\nIf EndText is missing, then the search will return all text found after StartText.\r\n\r\nIf both StartText and EndText are missing, then the entire Text string will be returned.\r\n\r\nIf StartText or EndText are not found within Text, then a \\`null\\` is returned.\r\n\r\n`,\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'Text',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tStartText: {\r\n\t\t\tname: 'StartText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tEndText: {\r\n\t\t\tname: 'EndText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function FindBetween\n\t * @returns {string}\n\t * The text found between StartText and EndText.\n\t * @summary Search a string and return the text found between StartText and EndText.\n\t * @description\n\t * \nThis function searches a string for StartText and EndText and returns all text found between the two.\n\nIf StartText is missing, then the search will return all text up to the found EndText.\n\nIf EndText is missing, then the search will return all text found after StartText.\n\nIf both StartText and EndText are missing, then the entire Text string will be returned.\n\nIf StartText or EndText are not found within Text, then a `null` is returned.\n\n\n\t * @param {string} Text\n\t * @param {string} [StartText]\n\t * @param {string} [EndText]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction FindBetween( Text, StartText, EndText ) \r\n\t{\r\n\t\tif ( typeof Text !== 'string' ) { throw new Error( `The parameter [Text] is required and must be a string.` ); }\r\n\t\tif ( ( StartText === undefined ) || ( StartText === null ) ) { StartText = ''; }\r\n\t\tif ( ( EndText === undefined ) || ( EndText === null ) ) { EndText = ''; }\r\n\t\tif ( typeof StartText !== 'string' ) { throw new Error( `The parameter [StartText] is optional but must be a string.` ); }\r\n\t\tif ( typeof EndText !== 'string' ) { throw new Error( `The parameter [EndText] is optional but must be a string.` ); }\r\n\r\n\t\t// Find StartText\r\n\t\tlet start_text_begin = 0;\r\n\t\tif ( StartText.length ) { start_text_begin = Text.indexOf( StartText ); }\r\n\t\tif ( start_text_begin < 0 ) { return null; }\r\n\r\n\t\t// Find EndText\r\n\t\tlet end_text_begin = Text.length;\r\n\t\tif ( EndText.length ) { end_text_begin = Text.indexOf( EndText, start_text_begin + StartText.length ); }\r\n\t\tif ( end_text_begin < 0 ) { return null; }\r\n\r\n\t\tlet found_text = Text.substring( start_text_begin + StartText.length, end_text_begin );\r\n\t\treturn found_text;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tFindBetween: FindBetween,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '214',\r\n\tmember_of: 'Text',\r\n\tname: 'ReplaceBetween',\r\n\ttype: 'function',\r\n\treturns: 'integer',\r\n\treturns_description: 'The new string with replacements performed.',\r\n\tsummary: 'Search a string for StartText and EndText and replace the text found between the two.',\r\n\tdescription: `\r\nThis function searches a string for StartText and EndText and replaces all text found between the two.\r\n\r\nIf StartText is missing, then all text found up to EndText will be replaced.\r\n\r\nIf EndText is missing, then all text found after StartText will be replaced.\r\n\r\nIf both StartText and EndText are missing, then the entire Text string will be replaced.\r\n\r\nIf StartText or EndText are not found within Text, then this function returns \\`0\\` to indicate that no replacements were performed.\r\n\r\nThe MaxTimes parameter specifies the maximum number of replacements to perform.\r\nIf MaxTimes is \\`-1\\`, then all possible replacements will be made throughout Text.\r\n`,\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'Text',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tStartText: {\r\n\t\t\tname: 'StartText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tEndText: {\r\n\t\t\tname: 'EndText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tReplacementText: {\r\n\t\t\tname: 'ReplacementText',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tMaxTimes: {\r\n\t\t\tname: 'MaxTimes',\r\n\t\t\ttype: 'number',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: 1,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ReplaceBetween\n\t * @returns {integer}\n\t * The new string with replacements performed.\n\t * @summary Search a string for StartText and EndText and replace the text found between the two.\n\t * @description\n\t * \nThis function searches a string for StartText and EndText and replaces all text found between the two.\n\nIf StartText is missing, then all text found up to EndText will be replaced.\n\nIf EndText is missing, then all text found after StartText will be replaced.\n\nIf both StartText and EndText are missing, then the entire Text string will be replaced.\n\nIf StartText or EndText are not found within Text, then this function returns `0` to indicate that no replacements were performed.\n\nThe MaxTimes parameter specifies the maximum number of replacements to perform.\nIf MaxTimes is `-1`, then all possible replacements will be made throughout Text.\n\n\t * @param {string} Text\n\t * @param {string} [StartText]\n\t * @param {string} [EndText]\n\t * @param {string} ReplacementText\n\t * @param {number} [MaxTimes=1]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ReplaceBetween( Text, StartText, EndText, ReplacementText, MaxTimes ) \r\n\t{\r\n\t\tif ( typeof Text !== 'string' ) { throw new Error( `The parameter [Text] is required and must be a string.` ); }\r\n\t\tif ( ( StartText === undefined ) || ( StartText === null ) ) { StartText = ''; }\r\n\t\tif ( ( EndText === undefined ) || ( EndText === null ) ) { EndText = ''; }\r\n\t\tif ( typeof StartText !== 'string' ) { throw new Error( `The parameter [StartText] is optional but must be a string.` ); }\r\n\t\tif ( typeof EndText !== 'string' ) { throw new Error( `The parameter [EndText] is optional but must be a string.` ); }\r\n\t\tif ( typeof ReplacementText !== 'string' ) { throw new Error( `The parameter [ReplacementText] is required and must be a string.` ); }\r\n\t\tif ( MaxTimes === undefined ) { MaxTimes = 1; }\r\n\t\tif ( typeof MaxTimes !== 'number' ) { throw new Error( `The parameter [MaxTimes] is optional but must be a number.` ); }\r\n\r\n\t\tlet text = Text;\r\n\t\tlet replacement_count = 0;\r\n\t\twhile ( true )\r\n\t\t{\r\n\t\t\tif ( ( MaxTimes >= 0 ) && ( replacement_count >= MaxTimes ) ) { break; }\r\n\t\t\tlet found_text = Liquicode.Text.FindBetween( text, StartText, EndText );\r\n\t\t\tif ( found_text === null ) { break; }\r\n\t\t\ttext = Liquicode.Text.ReplaceText( text, `${StartText}${found_text}${EndText}`, `${StartText}${ReplacementText}${EndText}`, 1 );\r\n\t\t\treplacement_count++;\r\n\t\t}\r\n\r\n\t\treturn text;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tReplaceBetween: ReplaceBetween,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '220',\r\n\tmember_of: 'Text',\r\n\tname: 'FirstWord',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Returns the first word of a text phrase.',\r\n\t],\r\n\tParameters: {\r\n\t\tPhrase: {\r\n\t\t\tname: 'Phrase',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t\tdescription: 'A text phrase containing words separated by delimiters.',\r\n\t\t},\r\n\t\tDelimiters: {\r\n\t\t\tname: 'Delimiters',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: ' ',\r\n\t\t\tdescription: 'A string of whitespace and punctuation characters that break the phrase into words.',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function FirstWord\n\t * @returns {string}\n\t * @description\n\t * Returns the first word of a text phrase.\n\t * @param {string} [Phrase]\n\t * A text phrase containing words separated by delimiters.\n\t * @param {string} [Delimiters=\" \"]\n\t * A string of whitespace and punctuation characters that break the phrase into words.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction FirstWord( Phrase, Delimiters )\r\n\t{\r\n\t\tPhrase = Liquicode.Types.Coerce( Phrase ).ToString();\r\n\t\tDelimiters = Liquicode.Types.Coerce( Delimiters ).ToString();\r\n\r\n\t\tlet word_start = -1;\r\n\t\tfor ( let index = 0; index < Phrase.length; index++ )\r\n\t\t{\r\n\t\t\tlet ch = Phrase.substr( index, 1 );\r\n\t\t\tif ( Delimiters.indexOf( ch ) >= 0 )\r\n\t\t\t{\r\n\t\t\t\tif ( word_start >= 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Phrase.substr( word_start, ( index - word_start ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( word_start < 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\tword_start = index;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ( word_start < 0 ) { return ''; }\r\n\t\treturn Phrase.substr( word_start );\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tFirstWord: FirstWord,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '221',\r\n\tmember_of: 'Text',\r\n\tname: 'AfterFirstWord',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Returns the remainder of a text phrase occurring after the first word.',\r\n\t],\r\n\tParameters: {\r\n\t\tPhrase: {\r\n\t\t\tname: 'Phrase',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t\tdescription: 'A text phrase containing words separated by delimiters.',\r\n\t\t},\r\n\t\tDelimiters: {\r\n\t\t\tname: 'Delimiters',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: ' ',\r\n\t\t\tdescription: 'A string of characters that break the phrase into words.',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function AfterFirstWord\n\t * @returns {string}\n\t * @description\n\t * Returns the remainder of a text phrase occurring after the first word.\n\t * @param {string} [Phrase]\n\t * A text phrase containing words separated by delimiters.\n\t * @param {string} [Delimiters=\" \"]\n\t * A string of characters that break the phrase into words.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction AfterFirstWord( Phrase, Delimiters )\r\n\t{\r\n\t\tPhrase = Liquicode.Types.Coerce( Phrase ).ToString();\r\n\t\tDelimiters = Liquicode.Types.Coerce( Delimiters ).ToString();\r\n\r\n\t\tfor ( let index = 0; index < Phrase.length; index++ )\r\n\t\t{\r\n\t\t\tlet ch = Phrase.substr( index, 1 );\r\n\t\t\tif ( Delimiters.indexOf( ch ) >= 0 )\r\n\t\t\t{\r\n\t\t\t\twhile ( Delimiters.indexOf( ch ) >= 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t\tif ( index >= Phrase.length ) { break; }\r\n\t\t\t\t\tch = Phrase.substr( index, 1 );\r\n\t\t\t\t}\r\n\t\t\t\treturn Phrase.substr( index );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn '';\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tAfterFirstWord: AfterFirstWord,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '222',\r\n\tmember_of: 'Text',\r\n\tname: 'LastWord',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Returns the last word of a text phrase.',\r\n\t],\r\n\tParameters: {\r\n\t\tPhrase: {\r\n\t\t\tname: 'Phrase',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t\tdescription: 'A text phrase containing words separated by delimiters.',\r\n\t\t},\r\n\t\tDelimiters: {\r\n\t\t\tname: 'Delimiters',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: ' ',\r\n\t\t\tdescription: 'A string of characters that break the phrase into words.',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function LastWord\n\t * @returns {string}\n\t * @description\n\t * Returns the last word of a text phrase.\n\t * @param {string} [Phrase]\n\t * A text phrase containing words separated by delimiters.\n\t * @param {string} [Delimiters=\" \"]\n\t * A string of characters that break the phrase into words.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction LastWord( Phrase, Delimiters )\r\n\t{\r\n\t\tPhrase = Liquicode.Types.Coerce( Phrase ).ToString();\r\n\t\tDelimiters = Liquicode.Types.Coerce( Delimiters ).ToString();\r\n\r\n\t\tlet word_end = -1;\r\n\t\tfor ( let index = Phrase.length - 1; index >= 0; index-- )\r\n\t\t{\r\n\t\t\tlet ch = Phrase.substr( index, 1 );\r\n\t\t\tif ( Delimiters.indexOf( ch ) >= 0 )\r\n\t\t\t{\r\n\t\t\t\tif ( word_end > 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\treturn Phrase.substr( index + 1, ( word_end - index ) );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif ( word_end < 0 )\r\n\t\t\t\t{\r\n\t\t\t\t\tword_end = index;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ( word_end < 0 ) { return ''; }\r\n\t\treturn Phrase.substr( 0, ( word_end - index ) );\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tLastWord: LastWord,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '223',\r\n\tmember_of: 'Text',\r\n\tname: 'BeforeLastWord',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: [\r\n\t\t'Returns the remainder of a text phrase occurring befiore the last word.',\r\n\t],\r\n\tParameters: {\r\n\t\tPhrase: {\r\n\t\t\tname: 'Phrase',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t\tdescription: 'A text phrase containing words separated by delimiters.',\r\n\t\t},\r\n\t\tDelimiters: {\r\n\t\t\tname: 'Delimiters',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: ' ',\r\n\t\t\tdescription: 'A string of characters that break the phrase into words.',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function BeforeLastWord\n\t * @returns {string}\n\t * @description\n\t * Returns the remainder of a text phrase occurring befiore the last word.\n\t * @param {string} [Phrase]\n\t * A text phrase containing words separated by delimiters.\n\t * @param {string} [Delimiters=\" \"]\n\t * A string of characters that break the phrase into words.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction BeforeLastWord( Phrase, Delimiters )\r\n\t{\r\n\t\tPhrase = Liquicode.Types.Coerce( Phrase ).ToString();\r\n\t\tDelimiters = Liquicode.Types.Coerce( Delimiters ).ToString();\r\n\r\n\t\tfor ( let index = Phrase.length - 1; index >= 0; index-- )\r\n\t\t{\r\n\t\t\tlet ch = Phrase.substr( index, 1 );\r\n\t\t\tif ( Delimiters.indexOf( ch ) >= 0 )\r\n\t\t\t{\r\n\t\t\t\treturn Phrase.substr( 0, index );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn '';\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tBeforeLastWord: BeforeLastWord,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '300',\r\n\tname: 'Shapes',\r\n\ttype: 'namespace',\r\n\tsummary: 'Functions for manipulating data in different shapes.',\r\n};\r\n\r\n\r\n//-start-jsdoc---------------------------------------------------------\r\n/**\n * @public\n * @namespace Shapes\n * @summary Functions for manipulating data in different shapes.\n*/\n//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\r\n\t\tMatrix: require( './310-Shapes.Matrix.js' )( Liquicode ).Matrix,\r\n\r\n\t};\r\n};\r\n\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '310',\r\n\tmember_of: 'Shapes',\r\n\tname: 'Matrix',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\treturns_summary: 'Returns a new Matrix object.',\r\n\tsummary: 'Matrix stores a two-dimensional jagged array and exposes manipulation functions.',\r\n\tdescription: `\r\nA Matrix object is essentially a two-dimensional array (an array of arrays).\r\nThis function will create and return a new Matrix object.\r\n\r\n\r\n***Values Parameter***\r\n\r\nYou can specify the initial contents of the Matrix with the Values parameter.\r\nIf Values is an array of arrays, then Matrix will contain those values.\r\nIf Values is a one-dimensional array, then Matrix will have a single row reflecting those values.\r\nIf Values is an integer, then Matrix will be created with that number of blank rows.\r\n\r\nNote that the only way to create a new Matrix with no rows in it is: \\`Shapes.Matrix( 0, Options )\\`\r\n\r\n\r\n***Options Parameter***\r\n\r\nThe Options parameter is an options object:\r\n~~~javascript\r\nOptions = {\r\n\tdefault_value: null,    // A default value to use when no other value exists.\r\n\tclone_values: true,     // If true, any values read from or written to the Matrix are cloned first.\r\n}\r\n~~~\r\n\r\nThe \\`clone_values\\` option is very important.\r\nIt is initialliy set to true, providing the safest and most sensible operation.\r\nA performance improvement can be had by setting this to false;\r\nHowever, unintended consequences may occur if you are not careful.\r\nAlsa, this is a valid intended consequence if you want to use Matrix to quickly manipulate an existing array.\r\n\r\nFor example:\r\n~~~javascript\r\nlet test_array = [\r\n\t[ 1, 2, 3, 4 ],\r\n\t[ 5, 6, 7, 8 ],\r\n];\r\n// test_array.length == 2\r\n// Encapsulate the array in a matrix.\r\nlet matrix = Liquicode.Shapes.Matrix( test_array, { clone_values: false } );\r\n// Append a row to the matrix.\r\nmatrix.AppendRows( [ 'A', 'B', 'C' ] );\r\n// Since test_array was not cloned first, the new row also appears in test_array.\r\n// test_array.length == 3 !!!\r\n~~~\r\n\r\n\r\n***How It Works***\r\n\r\nThe Matrix object contains a \\`RowData\\` member which is an array of arrays that contains the values for the matrix.\r\nThis is maintained as a jagged array, meaning that each row of the matrix may be of different lengths.\r\n~~~javascript\r\n[\t// Matrix maintains values in a jagged array:\r\n\t[ 1, 2, 3, 4 ],\r\n\t[ 1, 2, 3 ],\r\n\t[ 1, 2, 3, 4, 5 ],\r\n]\r\n~~~\r\n\r\nWhen calling the \\`AppendColumns\\`, \\`InsertColumns\\`, \\`SetColumn\\`, or \\`SetValue\\` functions,\r\nit may be necessary for the matrix to fill out the columns of shorter rows so that the target column exists.\r\nFor example, appending a blank column (\\`AppendColumns()\\`) to the matrix above would yield:\r\n~~~javascript\r\n[\t// Matrix fills columns with\r\n\t// default values as needed:\r\n\t[ 1, 2, 3, 4,    null, null ],\r\n\t[ 1, 2, 3, null, null, null ],\r\n\t[ 1, 2, 3, 4,    5,    null ],\r\n]\r\n~~~\r\nYou can change the value used to fill blank columns by changing \\`Option.default_value\\`.\r\n\r\n\r\n***Cell Addressing***\r\n\r\nWhen working with Matrix, you will usually need to identify a particular Row or Column to work with.\r\nMatrix supports three types of addressing modes:\r\n\r\n- 1) A zero-based index used as a row/column index.\r\nThis index must be greater than or equal to zero and less than the extent (i.e. the RowCount or ColumnCount).\r\n\r\n- 2) A negative index that serves as an offset from the extent (e.g. -1 = RowCount - 1).\r\nThis type of index must be between -extent and -1, inclusive.\r\n\r\n- 3) A spreadsheet style address (e.g. 'A1', 'B2', etc.).\r\nThis type of address has letters component which indicates a column.\r\nThis is followed by a digits component that is a one-based row number.\r\n\r\n\r\n***Matrix Functions***\r\n\r\nThe Matrix object also has a number of functions which allow you to manipulate the Matrix object.\r\n\r\n- Addressing Functions:\r\n\tThese are utility functions that assist when working with the spreadsheet style of addressing.\r\n\tThese functions are used internally by Matrix.\r\n\tThey do not consider the validity of any particular address or index within the current Matrix.\r\n\r\n\t- \\`IsValidAddress( Address )\\`:\r\n\t\tReturns \\`true\\` if Address is a valid address, otherwise \\`false\\`.\r\n\t\tA valid address must contain a column component in letters ('AB') and a row component in digits ('12').\r\n\t\tThis function determines only if the Address parameter is a properly formatted address,\r\n\t\tregardless if the address lies outside the bounds of this particular Matrix.\r\n\r\n\t- \\`NumberToLetters( Number )\\`:\r\n\t\tReturns the letters component of an address for any positive number (e.g. 1='A', 2='B', 28='AB', etc.).\r\n\r\n\t- \\`LettersToNumber( Address )\\`:\r\n\t\tConverts the letters component of an address to a positive number.\r\n\t\tAddress is a string that starts with, or is entirely composed of, letters.\r\n\r\n- Row Functions:\r\n\t\r\n\t- \\`RowIndexOf( Address )\\`:\r\n\tWill return a valid row index for this Matrix from the given Address.\r\n\tAddress can represent any of the three addressing styles.\r\n\r\n\t- \\`RowCount()\\`:\r\n\tReturns the number of rows within the Matrix.\r\n\r\n\t- \\`AppendRows( Values )\\`:\r\n\tAppends one or more rows to the end of the Matrix.\r\n\tIf Values is not supplied, then a blank row is appended.\r\n\tIf Values is a one-dimensional array, then a single row is appended.\r\n\tIf Values is a two-dimensional array, then multiple rows are appended.\r\n\r\n\t- \\`InsertRows( Row, Values )\\`:\r\n\tInserts one or more rows within the Matrix, starting at the given Row address.\r\n\tIf Values is not supplied, then a blank row is appended.\r\n\tIf Values is a one-dimensional array, then a single row is appended.\r\n\tIf Values is a two-dimensional array, then multiple rows are appended.\r\n\tNote that it is not possible to append a row to a Matrix by using this function.\r\n\r\n\t- \\`DeleteRows( Row, Count )\\`:\r\n\tDeletes one or more rows within the Matrix, starting at the given Row address.\r\n\tIf Count is not supplied, then a single row is deleted.\r\n\r\n\t- \\`GetRow( Row )\\`:\r\n\tReturns a single row of values from the Matrix, at the given Row address.\r\n\r\n\t- \\`SetRow( Row, Values )\\`:\r\n\tReplaces a single row of values (a one-dimensional array) within the Matrix, at the given Row address.\r\n\tIf Values is not supplied, then a blank row is set at that location.\r\n\r\n- Column Functions:\r\n\r\n\t- \\`ColumnIndexOf( Address )\\`:\r\n\tWill return a valid column index for this Matrix from the given Address.\r\n\tAddress can represent any of the three addressing styles.\r\n\r\n\t- \\`ColumnCount()\\`:\r\n\tReturns the number of columns within the Matrix.\r\n\r\n\t- \\`AppendColumns( Values )\\`:\r\n\tAppends one or more columns to the end of the Matrix.\r\n\tIf Values is not supplied, then a blank column is appended.\r\n\tIf Values is a one-dimensional array, then a single column is appended.\r\n\tIf Values is a two-dimensional array, then multiple columns are appended.\r\n\r\n\t- \\`InsertColumns( Column, Values )\\`:\r\n\tInserts one or more columns within the Matrix, starting at the given Column address.\r\n\tIf Values is not supplied, then a blank column is appended.\r\n\tIf Values is a one-dimensional array, then a single column is appended.\r\n\tIf Values is a two-dimensional array, then multiple columns are appended.\r\n\tNote that it is not possible to append a column to a Matrix by using this function.\r\n\r\n\t- \\`DeleteColumns( Column, Count )\\`:\r\n\tDeletes one or more columns within the Matrix, starting at the given Column address.\r\n\tIf Count is not supplied, then a single column is deleted.\r\n\r\n\t- \\`GetColumn( Column )\\`:\r\n\tReturns a single column of values from the Matrix, at the given Column address.\r\n\r\n\t- \\`SetColumn( Column, Values )\\`:\r\n\tReplaces a single column of values (a one-dimensional array) within the Matrix, at the given Column address.\r\n\tIf Values is not supplied, then a blank column is set at that location.\r\n\r\n- Value Functions:\r\n\r\n\t- \\`GetValue( Row, Column )\\`:\r\n\tReturns a single value located at Row and Column within the Matrix.\r\n\tRow can be a string address, in which case the Column parameter is omitted.\r\n\r\n\t- \\`SetValue( Row, Column, Value )\\`:\r\n\tSets a single value located at Row and Column within the Matrix.\r\n\tRow can be a string address, in which case the Column parameter is omitted.\r\n\t\r\n\t- \\`GetMatrix( Row, Column, RowCount, ColumnCount )\\`:\r\n\tConstructs a new Matrix of values from within the called Matrix.\r\n\tValues are taken starting at the location described by Row and Column and extending for RowCount rows and ColumnCount columns.\r\n\t\t- You can call this using four parameters: \\`GetMatrix( Row, Column, RowCount, ColumnCount )\\`\r\n\t\t- You can call this using three parameters: \\`GetMatrix( Address, RowCount, ColumnCount )\\`\r\n\t\t- You can call this using two parameters: \\`GetMatrix( Address, Size )\\`\r\n\r\n\t- \\`SetMatrix( Row, Column, Matrix )\\`:\r\n\tSets a matrix of values starting at Row and Column.\r\n\r\n- Table Functions:\r\n\r\n\t- \\`Clone()\\`:\r\n\tReturn a clone of this matrix.\r\n\tThe clone will contain a copy of this matrix's data and options.\r\n\r\n\t- \\`Transpose()\\`:\r\n\tReturn a copy of this matrix with its rows and column transposed.\r\n\r\n\t- \\`Join( AtColumn, JoinType, JoinMatrix, MatrixColumn )\\`:\r\n\tReturn a new matrix by joining this matrix with another one.\r\n\tThe join is produced by matching column values between the two matrices.\r\n\tThe different supported join types are: 'inner', 'left', 'right', and 'full'.\r\n\r\n`,\r\n\tParameters: {\r\n\t\tValues: {\r\n\t\t\tname: 'Values',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: true,\r\n\t\t\tdefault: [ [] ],\r\n\t\t\tdescription: 'One of: a two-dimensional array of arrays, a one-dimensional array of values, or an integer.',\r\n\t\t},\r\n\t\tOptions: {\r\n\t\t\tname: 'Options',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: {},\r\n\t\t\tdescription: 'Set of options controlling Matrix operation.',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Matrix\n\t * @returns {object}\n\t * @summary Matrix stores a two-dimensional jagged array and exposes manipulation functions.\n\t * @description\n\t * \nA Matrix object is essentially a two-dimensional array (an array of arrays).\nThis function will create and return a new Matrix object.\n\n\n***Values Parameter***\n\nYou can specify the initial contents of the Matrix with the Values parameter.\nIf Values is an array of arrays, then Matrix will contain those values.\nIf Values is a one-dimensional array, then Matrix will have a single row reflecting those values.\nIf Values is an integer, then Matrix will be created with that number of blank rows.\n\nNote that the only way to create a new Matrix with no rows in it is: `Shapes.Matrix( 0, Options )`\n\n\n***Options Parameter***\n\nThe Options parameter is an options object:\n~~~javascript\nOptions = {\n\tdefault_value: null,    // A default value to use when no other value exists.\n\tclone_values: true,     // If true, any values read from or written to the Matrix are cloned first.\n}\n~~~\n\nThe `clone_values` option is very important.\nIt is initialliy set to true, providing the safest and most sensible operation.\nA performance improvement can be had by setting this to false;\nHowever, unintended consequences may occur if you are not careful.\nAlsa, this is a valid intended consequence if you want to use Matrix to quickly manipulate an existing array.\n\nFor example:\n~~~javascript\nlet test_array = [\n\t[ 1, 2, 3, 4 ],\n\t[ 5, 6, 7, 8 ],\n];\n// test_array.length == 2\n// Encapsulate the array in a matrix.\nlet matrix = Liquicode.Shapes.Matrix( test_array, { clone_values: false } );\n// Append a row to the matrix.\nmatrix.AppendRows( [ 'A', 'B', 'C' ] );\n// Since test_array was not cloned first, the new row also appears in test_array.\n// test_array.length == 3 !!!\n~~~\n\n\n***How It Works***\n\nThe Matrix object contains a `RowData` member which is an array of arrays that contains the values for the matrix.\nThis is maintained as a jagged array, meaning that each row of the matrix may be of different lengths.\n~~~javascript\n[\t// Matrix maintains values in a jagged array:\n\t[ 1, 2, 3, 4 ],\n\t[ 1, 2, 3 ],\n\t[ 1, 2, 3, 4, 5 ],\n]\n~~~\n\nWhen calling the `AppendColumns`, `InsertColumns`, `SetColumn`, or `SetValue` functions,\nit may be necessary for the matrix to fill out the columns of shorter rows so that the target column exists.\nFor example, appending a blank column (`AppendColumns()`) to the matrix above would yield:\n~~~javascript\n[\t// Matrix fills columns with\n\t// default values as needed:\n\t[ 1, 2, 3, 4,    null, null ],\n\t[ 1, 2, 3, null, null, null ],\n\t[ 1, 2, 3, 4,    5,    null ],\n]\n~~~\nYou can change the value used to fill blank columns by changing `Option.default_value`.\n\n\n***Cell Addressing***\n\nWhen working with Matrix, you will usually need to identify a particular Row or Column to work with.\nMatrix supports three types of addressing modes:\n\n- 1) A zero-based index used as a row/column index.\nThis index must be greater than or equal to zero and less than the extent (i.e. the RowCount or ColumnCount).\n\n- 2) A negative index that serves as an offset from the extent (e.g. -1 = RowCount - 1).\nThis type of index must be between -extent and -1, inclusive.\n\n- 3) A spreadsheet style address (e.g. 'A1', 'B2', etc.).\nThis type of address has letters component which indicates a column.\nThis is followed by a digits component that is a one-based row number.\n\n\n***Matrix Functions***\n\nThe Matrix object also has a number of functions which allow you to manipulate the Matrix object.\n\n- Addressing Functions:\n\tThese are utility functions that assist when working with the spreadsheet style of addressing.\n\tThese functions are used internally by Matrix.\n\tThey do not consider the validity of any particular address or index within the current Matrix.\n\n\t- `IsValidAddress( Address )`:\n\t\tReturns `true` if Address is a valid address, otherwise `false`.\n\t\tA valid address must contain a column component in letters ('AB') and a row component in digits ('12').\n\t\tThis function determines only if the Address parameter is a properly formatted address,\n\t\tregardless if the address lies outside the bounds of this particular Matrix.\n\n\t- `NumberToLetters( Number )`:\n\t\tReturns the letters component of an address for any positive number (e.g. 1='A', 2='B', 28='AB', etc.).\n\n\t- `LettersToNumber( Address )`:\n\t\tConverts the letters component of an address to a positive number.\n\t\tAddress is a string that starts with, or is entirely composed of, letters.\n\n- Row Functions:\n\t\n\t- `RowIndexOf( Address )`:\n\tWill return a valid row index for this Matrix from the given Address.\n\tAddress can represent any of the three addressing styles.\n\n\t- `RowCount()`:\n\tReturns the number of rows within the Matrix.\n\n\t- `AppendRows( Values )`:\n\tAppends one or more rows to the end of the Matrix.\n\tIf Values is not supplied, then a blank row is appended.\n\tIf Values is a one-dimensional array, then a single row is appended.\n\tIf Values is a two-dimensional array, then multiple rows are appended.\n\n\t- `InsertRows( Row, Values )`:\n\tInserts one or more rows within the Matrix, starting at the given Row address.\n\tIf Values is not supplied, then a blank row is appended.\n\tIf Values is a one-dimensional array, then a single row is appended.\n\tIf Values is a two-dimensional array, then multiple rows are appended.\n\tNote that it is not possible to append a row to a Matrix by using this function.\n\n\t- `DeleteRows( Row, Count )`:\n\tDeletes one or more rows within the Matrix, starting at the given Row address.\n\tIf Count is not supplied, then a single row is deleted.\n\n\t- `GetRow( Row )`:\n\tReturns a single row of values from the Matrix, at the given Row address.\n\n\t- `SetRow( Row, Values )`:\n\tReplaces a single row of values (a one-dimensional array) within the Matrix, at the given Row address.\n\tIf Values is not supplied, then a blank row is set at that location.\n\n- Column Functions:\n\n\t- `ColumnIndexOf( Address )`:\n\tWill return a valid column index for this Matrix from the given Address.\n\tAddress can represent any of the three addressing styles.\n\n\t- `ColumnCount()`:\n\tReturns the number of columns within the Matrix.\n\n\t- `AppendColumns( Values )`:\n\tAppends one or more columns to the end of the Matrix.\n\tIf Values is not supplied, then a blank column is appended.\n\tIf Values is a one-dimensional array, then a single column is appended.\n\tIf Values is a two-dimensional array, then multiple columns are appended.\n\n\t- `InsertColumns( Column, Values )`:\n\tInserts one or more columns within the Matrix, starting at the given Column address.\n\tIf Values is not supplied, then a blank column is appended.\n\tIf Values is a one-dimensional array, then a single column is appended.\n\tIf Values is a two-dimensional array, then multiple columns are appended.\n\tNote that it is not possible to append a column to a Matrix by using this function.\n\n\t- `DeleteColumns( Column, Count )`:\n\tDeletes one or more columns within the Matrix, starting at the given Column address.\n\tIf Count is not supplied, then a single column is deleted.\n\n\t- `GetColumn( Column )`:\n\tReturns a single column of values from the Matrix, at the given Column address.\n\n\t- `SetColumn( Column, Values )`:\n\tReplaces a single column of values (a one-dimensional array) within the Matrix, at the given Column address.\n\tIf Values is not supplied, then a blank column is set at that location.\n\n- Value Functions:\n\n\t- `GetValue( Row, Column )`:\n\tReturns a single value located at Row and Column within the Matrix.\n\tRow can be a string address, in which case the Column parameter is omitted.\n\n\t- `SetValue( Row, Column, Value )`:\n\tSets a single value located at Row and Column within the Matrix.\n\tRow can be a string address, in which case the Column parameter is omitted.\n\t\n\t- `GetMatrix( Row, Column, RowCount, ColumnCount )`:\n\tConstructs a new Matrix of values from within the called Matrix.\n\tValues are taken starting at the location described by Row and Column and extending for RowCount rows and ColumnCount columns.\n\t\t- You can call this using four parameters: `GetMatrix( Row, Column, RowCount, ColumnCount )`\n\t\t- You can call this using three parameters: `GetMatrix( Address, RowCount, ColumnCount )`\n\t\t- You can call this using two parameters: `GetMatrix( Address, Size )`\n\n\t- `SetMatrix( Row, Column, Matrix )`:\n\tSets a matrix of values starting at Row and Column.\n\n- Table Functions:\n\n\t- `Clone()`:\n\tReturn a clone of this matrix.\n\tThe clone will contain a copy of this matrix's data and options.\n\n\t- `Transpose()`:\n\tReturn a copy of this matrix with its rows and column transposed.\n\n\t- `Join( AtColumn, JoinType, JoinMatrix, MatrixColumn )`:\n\tReturn a new matrix by joining this matrix with another one.\n\tThe join is produced by matching column values between the two matrices.\n\tThe different supported join types are: 'inner', 'left', 'right', and 'full'.\n\n\n\t * @param {object} Values\n\t * One of: a two-dimensional array of arrays, a one-dimensional array of values, or an integer.\n\t * @param {object} [Options={}]\n\t * Set of options controlling Matrix operation.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction Matrix( Values, Options )\r\n\t{\r\n\t\t// Validate the Values.\r\n\t\tif ( Liquicode.Types.IsFormat( Values, 'number:integer' ) ) \r\n\t\t{\r\n\t\t\t// Pass an integer as an initial row count for the Matrix.\r\n\t\t\tlet row_count = Values;\r\n\t\t\tValues = [];\r\n\t\t\tfor ( let row_index = 0; row_index < row_count; row_index++ )\r\n\t\t\t{\r\n\t\t\t\tValues.push( [] );\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if ( Liquicode.Types.IsFormat( Values, 'object:array-array' ) ) \r\n\t\t{\r\n\t\t\t// Pass an array of arrays as values in the Matrix.\r\n\t\t\t/* Do Nothing */\r\n\t\t}\r\n\t\telse if ( Liquicode.Types.IsFormat( Values, 'object:array' ) ) \r\n\t\t{\r\n\t\t\t// Pass a one-dimensional array as a single row in the Matrix.\r\n\t\t\tValues = [ Values ];\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\tthrow new Error( `The Values parameter must be one of: an array of arrays, a single row of values, or a row count.` );\r\n\t\t}\r\n\r\n\t\t// Validate the Options.\r\n\t\tif ( Options === undefined ) { Options = {}; }\r\n\t\tOptions = Liquicode.Object.Merge(\r\n\t\t\t{\r\n\t\t\t\tdefault_value: null,\r\n\t\t\t\tclone_values: true,\r\n\t\t\t},\r\n\t\t\tOptions );\r\n\r\n\t\tlet matrix = {\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tRowData: JSON.parse( JSON.stringify( Values ) ),\r\n\t\t\tOptions: JSON.parse( JSON.stringify( Options ) ),\r\n\r\n\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\t\t\t//\r\n\t\t\t//\t\tADDRESSING FUNCTIONS\r\n\t\t\t//\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tIsValidAddress: function ( Address )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Address !== 'string' ) { return false; }\r\n\t\t\t\tAddress = Address.toUpperCase();\r\n\t\t\t\tlet alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n\t\t\t\tlet digits = '0123456789';\r\n\t\t\t\tlet has_alpha = false;\r\n\t\t\t\tlet has_numeric = false;\r\n\t\t\t\tfor ( let index = 0; index < Address.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( !has_alpha )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( alphabet.indexOf( Address[ index ] ) < 0 ) { return false; } // Address must begin with an letter.\r\n\t\t\t\t\t\thas_alpha = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( alphabet.indexOf( Address[ index ] ) >= 0 )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ( has_numeric ) { return false; } // Address can only have other digits after the first digit.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if ( digits.indexOf( Address[ index ] ) >= 0 )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ( !has_alpha ) { return false; } // Address must begin with a letter.\r\n\t\t\t\t\t\t\thas_numeric = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn false; // Address can only have letters and digits.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( !has_alpha ) { return false; }\t\t// Address must contain letters followed by digits.\r\n\t\t\t\tif ( !has_numeric ) { return false; }\t// Address must contain letters followed by digits.\r\n\t\t\t\treturn true;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tNumberToLetters: function ( Number )\r\n\t\t\t{\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Number, 'number:integer' ) ) { throw new Error( `The Number parameter must be a positive integer.` ); }\r\n\t\t\t\tif ( Number <= 0 ) { throw new Error( `The Number parameter must be a positive integer.` ); }\r\n\t\t\t\t// FROM: https://cwestblog.com/2013/09/05/javascript-snippet-convert-number-to-column-name/\r\n\t\t\t\tfor ( var address = '', a = 1, b = 26; ( Number -= a ) >= 0; a = b, b *= 26 ) \r\n\t\t\t\t{\r\n\t\t\t\t\taddress = String.fromCharCode( parseInt( ( Number % b ) / a ) + 65 ) + address;\r\n\t\t\t\t}\r\n\t\t\t\treturn address;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tLettersToNumber: function ( Address )\r\n\t\t\t{\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Address, 'string:string' ) ) { throw new Error( `The Address parameter must be a string of letters.` ); }\r\n\t\t\t\tAddress = Address.toUpperCase();\r\n\t\t\t\tlet alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\r\n\t\t\t\tlet letters = '';\r\n\t\t\t\tlet number = 0;\r\n\t\t\t\tfor ( let index = 0; index < Address.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet ich = alphabet.indexOf( Address[ index ] );\r\n\t\t\t\t\tif ( ich < 0 ) { break; }\r\n\t\t\t\t\tletters += Address[ index ];\r\n\t\t\t\t}\r\n\t\t\t\tfor ( let index = 0; index < letters.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet ich = alphabet.indexOf( Address[ index ] );\r\n\t\t\t\t\tif ( ich < 0 ) { break; }\r\n\t\t\t\t\tnumber += ( ich + 1 ) * ( alphabet.length ** ( letters.length - ( index + 1 ) ) );\r\n\t\t\t\t}\r\n\t\t\t\treturn number;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\t\t\t//\r\n\t\t\t//\t\tMATRIX ROW FUNCTIONS\r\n\t\t\t//\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tRowIndexOf: function ( AddressOrIndex )\r\n\t\t\t{\r\n\t\t\t\tlet row_index = null;\r\n\t\t\t\tif ( typeof AddressOrIndex === 'string' )\r\n\t\t\t\t{\r\n\t\t\t\t\trow_index = Number( AddressOrIndex );\r\n\t\t\t\t\tif ( isNaN( row_index ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( !this.IsValidAddress( AddressOrIndex ) ) { throw new Error( `The value \"${AddressOrIndex}\" is not a valid address.` ); }\r\n\t\t\t\t\t\tfor ( let char_index = 0; char_index < AddressOrIndex.length; char_index++ )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ( '0123456789'.indexOf( AddressOrIndex[ char_index ] ) >= 0 )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\trow_index = Number( AddressOrIndex.substring( char_index ) );\r\n\t\t\t\t\t\t\t\trow_index--; // Convert from row number to row index.\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( isNaN( row_index ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrow new Error( `Unable to determine the row index of \"${AddressOrIndex}\".` );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if ( typeof AddressOrIndex === 'number' )\r\n\t\t\t\t{\r\n\t\t\t\t\trow_index = Math.floor( AddressOrIndex );\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new Error( `The AddressOrIndex parameter must be a string address (e.g. \"C2\") or an integer.` );\r\n\t\t\t\t}\r\n\t\t\t\tlet row_count = this.RowData.length;\r\n\t\t\t\tif ( row_index >= row_count ) { throw new Error( `The row index cannot be greater than or equal to the row count.` ); }\r\n\t\t\t\tif ( row_index < 0 ) { row_index += row_count; }\r\n\t\t\t\tif ( row_index < 0 ) { throw new Error( `The row index cannot be less than zero.` ); }\r\n\t\t\t\treturn row_index;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tRowCount: function ()\r\n\t\t\t{\r\n\t\t\t\treturn this.RowData.length;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tAppendRows: function ( Values )\r\n\t\t\t{\r\n\t\t\t\tif ( Values === undefined ) { Values = []; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array' ) ) { throw new Error( `The Values parameter must be an array of values.` ); }\r\n\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t{\r\n\t\t\t\t\tValues = JSON.parse( JSON.stringify( Values ) );\r\n\t\t\t\t}\r\n\t\t\t\tif ( Liquicode.Types.IsFormat( Values, 'object:array-array' ) ) \r\n\t\t\t\t{\r\n\t\t\t\t\tfor ( let row_index = 0; row_index < Values.length; row_index++ )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.RowData.push( Values[ row_index ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.RowData.push( Values );\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tInsertRows: function ( Row, Values )\r\n\t\t\t{\r\n\t\t\t\tif ( Values === undefined ) { Values = []; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array' ) ) { throw new Error( `The Values parameter must be an array of values.` ); }\r\n\t\t\t\tlet at_row_index = this.RowIndexOf( Row );\r\n\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t{\r\n\t\t\t\t\tValues = JSON.parse( JSON.stringify( Values ) );\r\n\t\t\t\t}\r\n\t\t\t\tif ( Liquicode.Types.IsFormat( Values, 'object:array-array' ) ) \r\n\t\t\t\t{\r\n\t\t\t\t\tfor ( let row_index = 0; row_index < Values.length; row_index++ )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.RowData.splice( at_row_index + row_index, 0, Values[ row_index ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.RowData.splice( at_row_index, 0, Values );\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tDeleteRows: function ( Row, Count ) \r\n\t\t\t{\r\n\t\t\t\tif ( Count === undefined ) { Count = 1; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Count, 'number:integer' ) ) { throw new Error( `The RowCount parameter must be a positive integer.` ); }\r\n\t\t\t\tif ( Count <= 0 ) { throw new Error( `The RowCount parameter must be a positive integer.` ); }\r\n\t\t\t\tlet row_index = this.RowIndexOf( Row );\r\n\t\t\t\tthis.RowData.splice( row_index, Count );\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tGetRow: function ( Row ) \r\n\t\t\t{\r\n\t\t\t\tlet at_row_index = this.RowIndexOf( Row );\r\n\t\t\t\tlet values = this.RowData[ at_row_index ];\r\n\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t{\r\n\t\t\t\t\tvalues = JSON.parse( JSON.stringify( values ) );\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tSetRow: function ( Row, Values )\r\n\t\t\t{\r\n\t\t\t\tif ( Values === undefined ) { Values = []; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array' ) ) { throw new Error( `The Values parameter must be an array of values.` ); }\r\n\t\t\t\tlet at_row_index = this.RowIndexOf( Row );\r\n\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t{\r\n\t\t\t\t\tValues = JSON.parse( JSON.stringify( Values ) );\r\n\t\t\t\t}\r\n\t\t\t\tthis.RowData[ at_row_index ] = Values;\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\t\t\t//\r\n\t\t\t//\t\tMATRIX COLUMN FUNCTIONS\r\n\t\t\t//\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tColumnIndexOf: function ( AddressOrIndex ) \r\n\t\t\t{\r\n\t\t\t\tlet column_index = null;\r\n\t\t\t\tif ( typeof AddressOrIndex === 'string' )\r\n\t\t\t\t{\r\n\t\t\t\t\tcolumn_index = Number( AddressOrIndex );\r\n\t\t\t\t\tif ( isNaN( column_index ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( !this.IsValidAddress( AddressOrIndex ) ) { throw new Error( `The value \"${AddressOrIndex}\" is not a valid address.` ); }\r\n\t\t\t\t\t\tcolumn_index = this.LettersToNumber( AddressOrIndex );\r\n\t\t\t\t\t\tif ( column_index === 0 ) { throw new Error( `The AddressOrIndex parameter must be a string address (e.g. \"C2\") or an integer.` ); }\r\n\t\t\t\t\t\tcolumn_index--; // Convert from column number to column index.\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if ( typeof AddressOrIndex === 'number' )\r\n\t\t\t\t{\r\n\t\t\t\t\tcolumn_index = Math.floor( AddressOrIndex );\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new Error( `The AddressOrIndex parameter must be a string address (e.g. \"C2\") or an integer.` );\r\n\t\t\t\t}\r\n\t\t\t\tlet column_count = this.ColumnCount();\r\n\t\t\t\tif ( column_index >= column_count ) { throw new Error( `The column index cannot be greater than or equal to the column count.` ); }\r\n\t\t\t\tif ( column_index < 0 ) { column_index += column_count; }\r\n\t\t\t\tif ( column_index < 0 ) { throw new Error( `The column index cannot be less than zero.` ); }\r\n\t\t\t\treturn column_index;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tColumnCount: function () \r\n\t\t\t{\r\n\t\t\t\tlet column_count = 0;\r\n\t\t\t\tfor ( let row_index = 0; row_index < this.RowData.length; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( column_count < this.RowData[ row_index ].length ) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcolumn_count = this.RowData[ row_index ].length;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn column_count;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tAppendColumns: function ( Values )\r\n\t\t\t{\r\n\t\t\t\tif ( Values === undefined ) { Values = []; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array' ) ) { throw new Error( `The Values parameter must be an array of values.` ); }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array-array' ) ) { Values = [ Values ]; }\r\n\t\t\t\tlet column_count = this.ColumnCount();\r\n\t\t\t\tfor ( let row_index = 0; row_index < this.RowData.length; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet row_values = this.RowData[ row_index ];\r\n\t\t\t\t\twhile ( row_values.length < column_count )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trow_values.push( this.Options.default_value );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor ( let column_index = 0; column_index < Values.length; column_index++ )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet column_values = Values[ column_index ];\r\n\t\t\t\t\t\tlet value = this.Options.default_value;\r\n\t\t\t\t\t\tif ( row_index < column_values.length )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvalue = column_values[ row_index ];\r\n\t\t\t\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trow_values.push( value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tInsertColumns: function ( Column, Values ) \r\n\t\t\t{\r\n\t\t\t\tif ( Values === undefined ) { Values = []; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array' ) ) { throw new Error( `The Values parameter must be an array of values.` ); }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array-array' ) ) { Values = [ Values ]; }\r\n\t\t\t\tlet at_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\tfor ( let row_index = 0; row_index < this.RowData.length; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet row_values = this.RowData[ row_index ];\r\n\t\t\t\t\twhile ( row_values.length <= at_column_index )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trow_values.push( this.Options.default_value );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfor ( let column_index = 0; column_index < Values.length; column_index++ )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet column_values = Values[ column_index ];\r\n\t\t\t\t\t\tlet value = this.Options.default_value;\r\n\t\t\t\t\t\tif ( row_index < column_values.length )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvalue = column_values[ row_index ];\r\n\t\t\t\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\trow_values.splice( ( at_column_index + column_index ), 0, value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tDeleteColumns: function ( Column, ColumnCount ) \r\n\t\t\t{\r\n\t\t\t\tif ( ColumnCount === undefined ) { ColumnCount = 1; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( ColumnCount, 'number:integer' ) ) { throw new Error( `The ColumnCount parameter must be a positive integer.` ); }\r\n\t\t\t\tif ( ColumnCount <= 0 ) { throw new Error( `The ColumnCount parameter must be a positive integer.` ); }\r\n\t\t\t\tlet at_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\tfor ( let row_index = 0; row_index < this.RowData.length; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet row_values = this.RowData[ row_index ];\r\n\t\t\t\t\tif ( row_values.length > at_column_index )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trow_values.splice( at_column_index, ColumnCount );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tGetColumn: function ( Column ) \r\n\t\t\t{\r\n\t\t\t\tlet values = [];\r\n\t\t\t\tlet at_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\tfor ( let row_index = 0; row_index < this.RowData.length; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet row_values = this.RowData[ row_index ];\r\n\t\t\t\t\tlet value = this.Options.default_value;\r\n\t\t\t\t\tif ( at_column_index < row_values.length )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = row_values[ at_column_index ];\r\n\t\t\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalues.push( value );\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tSetColumn: function ( Column, Values ) \r\n\t\t\t{\r\n\t\t\t\tif ( Values === undefined ) { Values = []; }\r\n\t\t\t\tif ( !Liquicode.Types.IsFormat( Values, 'object:array' ) ) { throw new Error( `The Values parameter must be an array of values.` ); }\r\n\t\t\t\tlet at_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\tfor ( let row_index = 0; row_index < this.RowData.length; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet row_values = this.RowData[ row_index ];\r\n\t\t\t\t\twhile ( row_values.length <= at_column_index )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\trow_values.push( this.Options.default_value );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlet value = this.Options.default_value;\r\n\t\t\t\t\tif ( row_index < Values.length )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = Values[ row_index ];\r\n\t\t\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\trow_values[ at_column_index ] = value;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\t\t\t//\r\n\t\t\t//\t\tMATRIX VALUE FUNCTIONS\r\n\t\t\t//\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tGetValue: function ( Row, Column ) \r\n\t\t\t{\r\n\t\t\t\tlet at_row_index = null;\r\n\t\t\t\tlet at_column_index = null;\r\n\t\t\t\tif ( ( typeof Row === 'string' ) && ( Column === undefined ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Row );\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\t}\r\n\t\t\t\tlet row_values = this.RowData[ at_row_index ];\r\n\t\t\t\tlet value = this.Options.default_value;\r\n\t\t\t\tif ( at_column_index < row_values.length )\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = row_values[ at_column_index ];\r\n\t\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn value;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tSetValue: function ( Row, Column, Value ) \r\n\t\t\t{\r\n\t\t\t\tlet at_row_index = null;\r\n\t\t\t\tlet at_column_index = null;\r\n\t\t\t\tif ( ( typeof Row === 'string' ) && ( Value === undefined ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Row );\r\n\t\t\t\t\tValue = Column;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\t}\r\n\t\t\t\tif ( Value === undefined ) { Value = this.Options.default_value; }\r\n\t\t\t\tlet row_values = this.RowData[ at_row_index ];\r\n\t\t\t\twhile ( at_column_index >= row_values.length )\r\n\t\t\t\t{\r\n\t\t\t\t\trow_values.push( this.Options.default_value );\r\n\t\t\t\t}\r\n\t\t\t\tlet value = Value;\r\n\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t{\r\n\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t}\r\n\t\t\t\trow_values[ at_column_index ] = value;\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tGetMatrix: function ( Row, Column, RowCount, ColumnCount ) \r\n\t\t\t{\r\n\t\t\t\tlet at_row_index = null;\r\n\t\t\t\tlet at_column_index = null;\r\n\t\t\t\tif ( ( typeof Row === 'string' ) && ( ColumnCount === undefined ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Row );\r\n\t\t\t\t\tColumnCount = RowCount;\r\n\t\t\t\t\tRowCount = Column;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\t}\r\n\t\t\t\tif ( RowCount === undefined ) { throw new Error( `The RowCount parameter is required.` ); }\r\n\t\t\t\tif ( ColumnCount === undefined ) { ColumnCount = RowCount; }\r\n\t\t\t\tlet target_matrix = Liquicode.Shapes.Matrix( 0, this.Options );\r\n\t\t\t\tfor ( let row_index = 0; row_index < RowCount; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( ( at_row_index + row_index ) >= this.RowData.length ) { break; }\r\n\t\t\t\t\tlet source_values = this.GetRow( at_row_index + row_index );\r\n\t\t\t\t\tlet target_values = [];\r\n\t\t\t\t\tfor ( let column_index = 0; column_index < ColumnCount; column_index++ )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( ( at_column_index + column_index ) >= source_values.length ) { break; }\r\n\t\t\t\t\t\ttarget_values.push( source_values[ at_column_index + column_index ] );\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttarget_matrix.AppendRows( target_values );\r\n\t\t\t\t}\r\n\t\t\t\treturn target_matrix;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tSetMatrix: function ( Row, Column, Matrix ) \r\n\t\t\t{\r\n\t\t\t\tlet at_row_index = null;\r\n\t\t\t\tlet at_column_index = null;\r\n\t\t\t\tif ( ( typeof Row === 'string' ) && ( Matrix === undefined ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Row );\r\n\t\t\t\t\tMatrix = Column;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tat_row_index = this.RowIndexOf( Row );\r\n\t\t\t\t\tat_column_index = this.ColumnIndexOf( Column );\r\n\t\t\t\t}\r\n\t\t\t\tif ( Matrix === undefined ) { throw new Error( `The Matrix parameter is required.` ); }\r\n\t\t\t\tif ( Matrix === null ) { throw new Error( `The Matrix parameter is required.` ); }\r\n\t\t\t\tlet source_row_count = Matrix.RowCount();\r\n\t\t\t\tlet source_column_count = Matrix.ColumnCount();\r\n\t\t\t\tfor ( let row_index = 0; row_index < source_row_count; row_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tfor ( let column_index = 0; column_index < source_column_count; column_index++ )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet value = Matrix.GetValue( row_index, column_index );\r\n\t\t\t\t\t\tvalue = JSON.parse( JSON.stringify( value ) );\r\n\t\t\t\t\t\tthis.SetValue( at_row_index + row_index, at_column_index + column_index, value );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\t\t\t//\r\n\t\t\t//\t\tTABLE FUNCTIONS\r\n\t\t\t//\r\n\t\t\t//=====================================================================\r\n\t\t\t//=====================================================================\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tClone: function () \r\n\t\t\t{\r\n\t\t\t\treturn Liquicode.Shapes.Matrix(\r\n\t\t\t\t\tJSON.parse( JSON.stringify( this.RowData ) ),\r\n\t\t\t\t\tJSON.parse( JSON.stringify( this.Options ) ),\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tTranspose: function () \r\n\t\t\t{\r\n\t\t\t\tlet new_matrix = Liquicode.Shapes.Matrix( 0 );\r\n\t\t\t\tlet column_count = this.ColumnCount();\r\n\t\t\t\tfor ( let column_index = 0; column_index < column_count; column_index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet values = this.GetColumn( column_index );\r\n\t\t\t\t\tnew_matrix.AppendRows( values );\r\n\t\t\t\t}\r\n\t\t\t\treturn new_matrix;\r\n\t\t\t},\r\n\r\n\r\n\t\t\t//---------------------------------------------------------------------\r\n\t\t\tJoin: function ( AtColumn, JoinType, RightMatrix, RightColumn ) \r\n\t\t\t{\r\n\t\t\t\t// Get the left and right column counts.\r\n\t\t\t\tlet left_column_count = this.ColumnCount();\r\n\t\t\t\tlet right_column_count = RightMatrix.ColumnCount();\r\n\r\n\t\t\t\t// Get the left join column.\r\n\t\t\t\tlet left_join_column = this.GetColumn( AtColumn );\r\n\r\n\t\t\t\t// Get the right join column.\r\n\t\t\t\tlet right_join_column = RightMatrix.GetColumn( RightColumn );\r\n\r\n\t\t\t\t// Get the left values.\r\n\t\t\t\tlet left_values = this.RowData;\r\n\r\n\t\t\t\t// Get the right values.\r\n\t\t\t\tlet right_values = RightMatrix.RowData;\r\n\r\n\t\t\t\t// Build the join map.\r\n\t\t\t\tlet join_map = [];\r\n\t\t\t\tJoinType = JoinType.toLowerCase();\r\n\t\t\t\tif ( JoinType === 'inner' )\r\n\t\t\t\t{\r\n\t\t\t\t\tleft_join_column.forEach(\r\n\t\t\t\t\t\t( left_join_value, left_join_index ) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tright_join_column.forEach(\r\n\t\t\t\t\t\t\t\t( right_join_value, right_join_index ) =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif ( right_join_value === left_join_value )\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tjoin_map.push( { left: left_join_index, right: right_join_index } );\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( JoinType === 'left' )\r\n\t\t\t\t{\r\n\t\t\t\t\tleft_join_column.forEach(\r\n\t\t\t\t\t\t( left_join_value, left_join_index ) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet join_count = 0;\r\n\t\t\t\t\t\t\tright_join_column.forEach(\r\n\t\t\t\t\t\t\t\t( right_join_value, right_join_index ) =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif ( right_join_value === left_join_value )\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tjoin_map.push( { left: left_join_index, right: right_join_index } );\r\n\t\t\t\t\t\t\t\t\t\tjoin_count++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t\tif ( !join_count ) { join_map.push( { left: left_join_index, right: null } ); }\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( JoinType === 'right' )\r\n\t\t\t\t{\r\n\t\t\t\t\tright_join_column.forEach(\r\n\t\t\t\t\t\t( right_join_value, right_join_index ) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet join_count = 0;\r\n\t\t\t\t\t\t\tleft_join_column.forEach(\r\n\t\t\t\t\t\t\t\t( left_join_value, left_join_index ) =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif ( right_join_value === left_join_value )\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tjoin_map.push( { left: left_join_index, right: right_join_index } );\r\n\t\t\t\t\t\t\t\t\t\tjoin_count++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t\tif ( !join_count ) { join_map.push( { left: null, right: right_join_index } ); }\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( JoinType === 'full' )\r\n\t\t\t\t{\r\n\t\t\t\t\tleft_join_column.forEach(\r\n\t\t\t\t\t\t( left_join_value, left_join_index ) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet join_count = 0;\r\n\t\t\t\t\t\t\tright_join_column.forEach(\r\n\t\t\t\t\t\t\t\t( right_join_value, right_join_index ) =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif ( right_join_value === left_join_value )\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tjoin_map.push( { left: left_join_index, right: right_join_index } );\r\n\t\t\t\t\t\t\t\t\t\tjoin_count++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t\tif ( !join_count ) { join_map.push( { left: left_join_index, right: null } ); }\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t\tright_join_column.forEach(\r\n\t\t\t\t\t\t( right_join_value, right_join_index ) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet join_count = 0;\r\n\t\t\t\t\t\t\tleft_join_column.forEach(\r\n\t\t\t\t\t\t\t\t( left_join_value, left_join_index ) =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif ( right_join_value === left_join_value )\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tjoin_count++;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t\tif ( !join_count ) { join_map.push( { left: null, right: right_join_index } ); }\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tthrow new Error( `The [JoinType] parameter has an unknown value \"${JoinType}\".` );\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Join the data.\r\n\t\t\t\tlet join_matrix = [];\r\n\t\t\t\tjoin_map.forEach(\r\n\t\t\t\t\tjoin =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// let row_index = this.RowCount();\r\n\t\t\t\t\t\tlet join_row = [];\r\n\t\t\t\t\t\tlet has_values = false;\r\n\r\n\t\t\t\t\t\tfor ( let index = 0; index < left_column_count; index++ )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ( ( join.left !== null ) && ( index < left_values[ join.left ].length ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Append left data values.\r\n\t\t\t\t\t\t\t\tjoin_row.push( left_values[ join.left ][ index ] );\r\n\t\t\t\t\t\t\t\thas_values = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tjoin_row.push( this.Options.default_value );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfor ( let index = 0; index < right_column_count; index++ )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif ( ( join.right !== null ) && ( index < right_values[ join.right ].length ) )\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t// Append left data values.\r\n\t\t\t\t\t\t\t\tjoin_row.push( right_values[ join.right ][ index ] );\r\n\t\t\t\t\t\t\t\thas_values = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tjoin_row.push( this.Options.default_value );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( has_values )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tjoin_matrix.push( join_row );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t\tif ( this.Options.clone_values )\r\n\t\t\t\t{\r\n\t\t\t\t\tjoin_matrix = JSON.parse( JSON.stringify( join_matrix ) );\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn Liquicode.Shapes.Matrix( join_matrix, this.Options );\r\n\t\t\t},\r\n\r\n\t\t};\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// Assign the initial matrix values.\r\n\t\tif ( Options.clone_values )\r\n\t\t{\r\n\t\t\tValues = JSON.parse( JSON.stringify( Values ) );\r\n\t\t}\r\n\t\tmatrix.RowData = Values;\r\n\r\n\t\t//---------------------------------------------------------------------\r\n\t\t// Return the new Matrix.\r\n\t\treturn matrix;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tMatrix: Matrix,\r\n\t};\r\n};\r\n","\"use strict\";\n\n\n//---------------------------------------------------------------------\nlet Schema = {\n\tid: '500',\n\tname: 'Parse',\n\ttype: 'namespace',\n\tsummary: 'Functions for tokenizing text strings.',\n};\n\n\n//-start-jsdoc---------------------------------------------------------\n/**\n * @public\n * @namespace Parse\n * @summary Functions for tokenizing text strings.\n*/\n//-end-jsdoc-----------------------------------------------------------\n\n\n//---------------------------------------------------------------------\nmodule.exports = function ( Liquicode )\n{\n\treturn {\n\t\t_Schema: Schema,\n\t\tTokenizeOptions: require( './501-Parse.TokenizeOptions.js' )( Liquicode ).TokenizeOptions,\n\t\tTokenize: require( './502-Parse.Tokenize.js' )( Liquicode ).Tokenize,\n\t\tDateParse: require( './510-Parse.DateParse.js' )( Liquicode ).DateParse,\n\t};\n};\n\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '501',\r\n\tmember_of: 'Parse',\r\n\tname: 'TokenizeOptions',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: [\r\n\t\t'Returns a set of options for calling Tokenize().',\r\n\t\t'Throws an error if an invalid value for PresetName is given.',\r\n\t],\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'PresetName',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t\tdescription: [\r\n\t\t\t\t`To retrieve an options preset, use one of: 'csv', or 'cli'`,\r\n\t\t\t\t`You can leave this empty or 'default' for the default options.`,\r\n\t\t\t],\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function TokenizeOptions\n\t * @returns {object}\n\t * @description\n\t * Returns a set of options for calling Tokenize().\n\t * Throws an error if an invalid value for PresetName is given.\n\t * @param {string} [PresetName]\n\t * To retrieve an options preset, use one of: 'csv', or 'cli'\n\t * You can leave this empty or 'default' for the default options.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction TokenizeOptions( PresetName )\r\n\t{\r\n\t\tlet options = {\r\n\t\t\twhitespace: ` \\t\\r\\n`,\r\n\t\t\tsymbols: `.;,:<>+-*/^()[]{}=`,\r\n\t\t\tliteral_delimiters: `'\"`,\r\n\t\t\tliteral_escape_chars: `\\\\`,\r\n\t\t\tself_escape_literal_delimiters: false,\r\n\t\t\tkeywords: [],\r\n\t\t\tkeywords_are_case_sensitive: false,\r\n\t\t\tdiscard_whitespace: false,\r\n\t\t\tresolve_literal_values: false,\r\n\t\t\tresolve_numeric_values: false,\r\n\t\t};\r\n\t\tif ( !PresetName || PresetName === 'default' )\r\n\t\t{\r\n\t\t\t/* Do Nothing */\r\n\t\t}\r\n\t\telse if ( PresetName === 'csv' )\r\n\t\t{\r\n\t\t\toptions.symbols = `,`; // Comma seperated values.\r\n\t\t\toptions.literal_delimiters = `\"`; // Use double quotes around values.\r\n\t\t\toptions.literal_escape_chars = `\\\\`; // Allow an escape character.\r\n\t\t\toptions.self_escape_literal_delimiters = true; // Allow self-delimiting double quotes.\r\n\t\t\toptions.resolve_literal_values = true;\r\n\t\t}\r\n\t\telse if ( PresetName === 'cli' )\r\n\t\t{\r\n\t\t\toptions.whitespace = ` \\t\\r\\n`;\r\n\t\t\toptions.symbols = `-:=`;\r\n\t\t\toptions.literal_delimiters = `'\"`;\r\n\t\t\toptions.literal_escape_chars = `\\\\`;\r\n\t\t\toptions.keywords = [];\r\n\t\t\toptions.discard_whitespace = true;\r\n\t\t\toptions.resolve_literal_values = true;\r\n\t\t\toptions.resolve_numeric_values = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthrow new Error( `The parameter [PresetName] has an invalid value of [${PresetName}]. Must be one of: 'default', 'csv', or 'cli'.` );\r\n\t\t}\r\n\t\treturn options;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\t\tTokenizeOptions: TokenizeOptions,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '502',\r\n\tmember_of: 'Parse',\r\n\tname: 'Tokenize',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\tdescription: [\r\n\t\t'Returns the parsed tokens.',\r\n\t],\r\n\tParameters: {\r\n\t\tText: {\r\n\t\t\tname: 'PresetName',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t\tdescription: [\r\n\t\t\t\t`To retrieve an options preset, use one of: 'csv', or 'cli'`,\r\n\t\t\t\t`You can leave this empty for the default options.`,\r\n\t\t\t],\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function Tokenize\n\t * @returns {object}\n\t * @description\n\t * Returns the parsed tokens.\n\t * @param {string} [PresetName]\n\t * To retrieve an options preset, use one of: 'csv', or 'cli'\n\t * You can leave this empty for the default options.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction Tokenize( Text, Options )\r\n\t{\r\n\t\t// Get the options.\r\n\t\tlet tokenize_options = Liquicode.Parse.TokenizeOptions();\r\n\t\ttokenize_options = Liquicode.Object.Merge( tokenize_options, Options );\r\n\r\n\t\t// Tokenize the text.\r\n\t\tlet tokens = [];\r\n\t\tif ( !Text ) { return tokens; }\r\n\r\n\t\tlet ichar = 0;\r\n\t\tlet len = Text.length;\r\n\t\twhile ( true )\r\n\t\t{\r\n\t\t\t// Exit loop when reached end of text string.\r\n\t\t\tif ( ichar === len ) { break; }\r\n\r\n\t\t\t// Parse the next token.\r\n\t\t\tlet token = read_whitespace( tokenize_options, Text, ichar );\r\n\t\t\tif ( !token ) { token = read_symbol( tokenize_options, Text, ichar ); }\r\n\t\t\tif ( !token ) { token = read_literal( tokenize_options, Text, ichar ); }\r\n\t\t\tif ( !token ) { token = read_numeric( tokenize_options, Text, ichar ); }\r\n\t\t\tif ( !token ) { token = read_identifier( tokenize_options, Text, ichar ); }\r\n\t\t\tif ( !token ) { throw new Error( `Unable to continue parsing at location ${ichar}.` ); }\r\n\t\t\tichar += token.token.length;\r\n\r\n\t\t\t// Collect tokens.\r\n\t\t\tif (\r\n\t\t\t\ttoken\r\n\t\t\t\t&& ( token.type === TokenTypes.whitespace )\r\n\t\t\t\t&& tokenize_options.discard_whitespace\r\n\t\t\t) { continue; }\r\n\t\t\ttokens.push( token );\r\n\t\t}\r\n\r\n\t\t// Do required value conversions.\r\n\t\tconvert_values( tokenize_options, tokens );\r\n\r\n\t\t// Return the tokens.\r\n\t\treturn tokens;\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tconst TokenTypes =\r\n\t{\r\n\t\twhitespace: 'whitespace',\r\n\t\tsymbol: 'symbol',\r\n\t\tdelimiter: 'delimiter',\r\n\t\tliteral: 'literal',\r\n\t\tidentifier: 'identifier',\r\n\t\tnumeric: 'numeric',\r\n\t\tkeyword: 'keyword',\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction read_whitespace( Options, Text, StartAt )\r\n\t{\r\n\t\tlet ichar = StartAt;\r\n\t\tlet len = Text.length;\r\n\t\twhile ( Options.whitespace.includes( Text.charAt( ichar ) ) ) \r\n\t\t{\r\n\t\t\tichar++;\r\n\t\t\tif ( ichar === len ) { break; }\r\n\t\t}\r\n\t\tif ( ichar === StartAt ) { return null; }\r\n\t\tlet token = {\r\n\t\t\ttype: TokenTypes.whitespace,\r\n\t\t\ttoken: Text.substring( StartAt, ichar ),\r\n\t\t\tat: StartAt\r\n\t\t};\r\n\t\treturn token;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction read_symbol( Options, Text, StartAt )\r\n\t{\r\n\t\tif ( !Options.symbols.includes( Text.charAt( StartAt ) ) ) { return null; }\r\n\t\tlet token = {\r\n\t\t\ttype: TokenTypes.symbol,\r\n\t\t\ttoken: Text.charAt( StartAt ),\r\n\t\t\tat: StartAt\r\n\t\t};\r\n\t\treturn token;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction read_numeric( Options, Text, StartAt )\r\n\t{\r\n\t\tlet ichar = StartAt;\r\n\t\tlet len = Text.length;\r\n\t\twhile ( true ) \r\n\t\t{\r\n\t\t\tlet ch = Text.charAt( ichar );\r\n\t\t\tif (\r\n\t\t\t\t( ( ch >= '0' ) && ( ch <= '9' ) )\r\n\t\t\t\t|| ( ch === '.' ) )\r\n\t\t\t{ ichar++; }\r\n\t\t\telse\r\n\t\t\t{ break; }\r\n\t\t\tif ( ichar === len ) { break; }\r\n\t\t}\r\n\t\tif ( ichar === StartAt ) { return null; }\r\n\t\tlet token = {\r\n\t\t\ttype: TokenTypes.numeric,\r\n\t\t\ttoken: Text.substring( StartAt, ichar ),\r\n\t\t\tat: StartAt\r\n\t\t};\r\n\t\treturn token;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction read_literal( Options, Text, StartAt )\r\n\t{\r\n\t\tif ( !Options.literal_delimiters.includes( Text.charAt( StartAt ) ) ) { return null; }\r\n\t\tlet start_char = Text.charAt( StartAt );\r\n\t\tlet ichar = StartAt + 1;\r\n\t\tlet len = Text.length;\r\n\t\twhile ( true ) \r\n\t\t{\r\n\t\t\tif ( ichar >= len ) { break; }\r\n\t\t\tlet ch = Text.charAt( ichar );\r\n\t\t\t// Check for self escaping delimiters (e.g. \"Hello \"\"World\"\"!\").\r\n\t\t\tif ( Options.self_escape_literal_delimiters\r\n\t\t\t\t&& Options.literal_delimiters.includes( ch )\r\n\t\t\t\t&& ( ( ichar + 1 ) < len )\r\n\t\t\t\t&& ( ch === Text.charAt( ichar + 1 ) )\r\n\t\t\t) \r\n\t\t\t{\r\n\t\t\t\tichar++; // Take the first instance of the character.\r\n\t\t\t\tichar++; // Take the second instance of the character.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Check for an escape character.\r\n\t\t\tif ( Options.literal_escape_chars.includes( ch ) )\r\n\t\t\t{\r\n\t\t\t\tichar++; // Take the escape character.\r\n\t\t\t\tichar++; // Take the escaped character.\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\t// Check if we found the closing delimiter for this literal.\r\n\t\t\tif ( ch === start_char )\r\n\t\t\t{\r\n\t\t\t\t// Found the end of the literal.\r\n\t\t\t\tichar++; // Take the closing delimiter.\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t// Check for the end of the given string.\r\n\t\t\tichar++;\r\n\t\t\tif ( ichar >= len ) { break; }\r\n\t\t}\r\n\t\tif ( ichar === StartAt ) { return null; }\r\n\t\tlet token = {\r\n\t\t\ttype: TokenTypes.literal,\r\n\t\t\ttoken: Text.substring( StartAt, ichar ),\r\n\t\t\tat: StartAt\r\n\t\t};\r\n\t\treturn token;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction read_identifier( Options, Text, StartAt )\r\n\t{\r\n\t\tlet ichar = StartAt;\r\n\t\tlet len = Text.length;\r\n\t\twhile ( true )\r\n\t\t{\r\n\t\t\tlet ch = Text.charAt( ichar );\r\n\t\t\tif ( Options.whitespace.includes( ch ) ) { break; }\r\n\t\t\tif ( Options.symbols.includes( ch ) ) { break; }\r\n\t\t\tif ( Options.literal_delimiters.includes( ch ) ) { break; }\r\n\t\t\tichar++;\r\n\t\t\tif ( ichar === len ) { break; }\r\n\t\t}\r\n\t\tif ( ichar === StartAt ) { return null; }\r\n\t\tlet token = {\r\n\t\t\ttype: TokenTypes.identifier,\r\n\t\t\ttoken: Text.substring( StartAt, ichar ),\r\n\t\t\tat: StartAt\r\n\t\t};\r\n\r\n\t\t// Detect keywords.\r\n\t\tlet is_keyword = false;\r\n\t\tif ( Options.keywords_are_case_sensitive )\r\n\t\t{\r\n\t\t\tis_keyword = Options.keywords.find(\r\n\t\t\t\tkeyword => ( keyword === token.token )\r\n\t\t\t);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tis_keyword = Options.keywords.find(\r\n\t\t\t\tkeyword => ( keyword.toLowerCase() === token.token.toLowerCase() )\r\n\t\t\t);\r\n\t\t}\r\n\t\tif ( is_keyword )\r\n\t\t{\r\n\t\t\ttoken.type = TokenTypes.keyword;\r\n\t\t}\r\n\r\n\t\t// Return the token.\r\n\t\treturn token;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction convert_values( Options, Tokens )\r\n\t{\r\n\t\tTokens.forEach(\r\n\t\t\t( token ) =>\r\n\t\t\t{\r\n\t\t\t\tif ( token.type === TokenTypes.numeric )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( Options.resolve_numeric_values )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( token.token.indexOf( '.' ) >= 0 )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Convert to float value.\r\n\t\t\t\t\t\t\ttoken.token = parseFloat( token.token );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Convert to integer value.\r\n\t\t\t\t\t\t\ttoken.token = parseInt( token.token );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if ( token.type === TokenTypes.literal )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( Options.resolve_literal_values )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Remove the surrounding quote characters.\r\n\t\t\t\t\t\ttoken.token = token.token.substr( 1, token.token.length - 2 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t} );\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\t\tTokenize: Tokenize,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '011',\r\n\tmember_of: 'Parse',\r\n\tname: 'DateParse',\r\n\ttype: 'function',\r\n\treturns: 'object',\r\n\treturns_summary: 'Returns a \\`DateParts\\` object containing Date/Time detail.',\r\n\tdescription: [ `\r\nDates and times are funny little creatures.\r\n`],\r\n\tParameters: {\r\n\t\tValue: {\r\n\t\t\tname: 'Value',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tTimeZoneOffset: {\r\n\t\t\tname: 'TimeZoneOffset',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '+0000',\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function DateParse\n\t * @returns {object}\n\t * @description\n\t * \nDates and times are funny little creatures.\n\n\t * @param {string} Value\n\t * @param {string} [TimeZoneOffset=\"+0000\"]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction DateParse( Value, TimeZoneOffset = '+0000' )\r\n\t{\r\n\t\tValue = Liquicode.Types.Coerce( Value ).ToString();\r\n\r\n\t\t// Prepare and validate the date string.\r\n\t\tValue = Value.toLowerCase().trim();\r\n\t\tif ( !Value ) { return get_date_parts( null, TimeZoneOffset ); }\r\n\r\n\t\t// Validate AssumeTimeZone\r\n\t\tif ( !TimeZoneOffset ) { TimeZoneOffset = '+0000'; }\r\n\t\tif ( !TimeZoneOffset.startsWith( '+' ) && !TimeZoneOffset.startsWith( '-' ) )\r\n\t\t{\r\n\t\t\tthrow new Error( `AssumeTimeZone must begin with a plus or minus sign.` );\r\n\t\t}\r\n\t\tlet offset = TimeZoneOffset.substr( 1 );\r\n\t\tif ( ( offset.length !== 4 ) || isNaN( offset ) )\r\n\t\t{\r\n\t\t\tthrow new Error( `AssumeTimeZone must have a four digit offset component.` );\r\n\t\t}\r\n\r\n\t\tlet date = null;\r\n\r\n\t\t// Try some unusual cases of compressed timestamps.\r\n\t\tif ( !isNaN( Number( Value ) ) )\r\n\t\t{\r\n\t\t\tlet s = Number( Value ).toString(); // Remove any noise.\r\n\t\t\tif ( s.length == 8 )\r\n\t\t\t{\r\n\t\t\t\t// 20180329 => 2018-03-29\r\n\t\t\t\ts = (\r\n\t\t\t\t\ts.substr( 0, 4 ) + '-' +\r\n\t\t\t\t\ts.substr( 4, 2 ) + '-' +\r\n\t\t\t\t\ts.substr( 6, 2 ) +\r\n\t\t\t\t\t' 00:00:00 ' + TimeZoneOffset\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t\telse if ( s.length == 10 )\r\n\t\t\t{\r\n\t\t\t\t// 1465241631 => 1465241631000 => Date(1465241631000)\r\n\t\t\t\ts += '000'; // milliseconds\r\n\t\t\t\ts = Number( s );\r\n\t\t\t}\r\n\t\t\telse if ( s.length == 13 )\r\n\t\t\t{\r\n\t\t\t\t// 1465241631000 => Date(1465241631000)\r\n\t\t\t\ts = s; // milliseconds\r\n\t\t\t\ts = Number( s );\r\n\t\t\t}\r\n\t\t\telse if ( s.length == 14 )\r\n\t\t\t{\r\n\t\t\t\t// 20180329074753 => 2018-03-29 07:47:53\r\n\t\t\t\ts = (\r\n\t\t\t\t\ts.substr( 0, 4 ) + '-' +\r\n\t\t\t\t\ts.substr( 4, 2 ) + '-' +\r\n\t\t\t\t\ts.substr( 6, 2 ) + ' ' +\r\n\t\t\t\t\ts.substr( 8, 2 ) + ':' +\r\n\t\t\t\t\ts.substr( 10, 2 ) + ':' +\r\n\t\t\t\t\ts.substr( 12, 2 ) +\r\n\t\t\t\t\t' ' + TimeZoneOffset\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// Try the javascript date parsing.\r\n\t\t\tdate = new Date( s );\r\n\t\t\tif ( !isNaN( date.getTime() ) ) { return get_date_parts( date, TimeZoneOffset ); }\r\n\t\t}\r\n\r\n\t\t// Test for ISO format: 2005-05-01T15:05:23.000Z\r\n\t\tif (\r\n\t\t\t( Value.length >= 24 )\r\n\t\t\t&& ( Value.substr( 4, 1 ) === '-' )\r\n\t\t\t&& ( Value.substr( 7, 1 ) === '-' )\r\n\t\t\t&& ( Value.substr( 10, 1 ) === 't' )\r\n\t\t\t&& ( Value.substr( 13, 1 ) === ':' )\r\n\t\t\t&& ( Value.substr( 16, 1 ) === ':' )\r\n\t\t\t&& ( Value.substr( 19, 1 ) === '.' )\r\n\t\t\t&& ( Value.substr( 23, 1 ) === 'z' )\r\n\t\t)\r\n\t\t{\r\n\t\t\ttry { date = new Date( Value ); }\r\n\t\t\tcatch ( e ) { }\r\n\t\t\tif ( date && !isNaN( date.getTime() ) ) { return get_date_parts( date, TimeZoneOffset ); }\r\n\t\t\telse { return get_date_parts( null, TimeZoneOffset ); }\r\n\t\t}\r\n\r\n\t\t// Test for ISO format (short): 2005-05-01T15:05:23Z\r\n\t\tif (\r\n\t\t\t( Value.length >= 20 )\r\n\t\t\t&& ( Value.substr( 4, 1 ) === '-' )\r\n\t\t\t&& ( Value.substr( 7, 1 ) === '-' )\r\n\t\t\t&& ( Value.substr( 10, 1 ) === 't' )\r\n\t\t\t&& ( Value.substr( 13, 1 ) === ':' )\r\n\t\t\t&& ( Value.substr( 16, 1 ) === ':' )\r\n\t\t\t&& ( Value.substr( 19, 1 ) === 'z' )\r\n\t\t)\r\n\t\t{\r\n\t\t\ttry { date = new Date( Value ); }\r\n\t\t\tcatch ( e ) { }\r\n\t\t\tif ( date && !isNaN( date.getTime() ) )\r\n\t\t\t{ return get_date_parts( date, TimeZoneOffset ); }\r\n\t\t\telse { return get_date_parts( null, TimeZoneOffset ); }\r\n\t\t}\r\n\r\n\t\t// We know its not a javascript supported format.\r\n\t\t// We have to do it the hard way.\r\n\t\tlet tokens = tokenize_date( Value );\r\n\t\tlet symbols = tokens2symbols( tokens );\r\n\t\tdate = symbols2date( symbols, TimeZoneOffset );\r\n\r\n\t\t// Return the date.\r\n\t\tif ( date && !isNaN( date.getTime() ) )\r\n\t\t{ return get_date_parts( date, TimeZoneOffset ); }\r\n\t\telse { return get_date_parts( null, TimeZoneOffset ); }\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tconst REFS =\r\n\t{\r\n\t\tday_of_week: [ 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday' ],\r\n\t\tday_of_week_abbrev: [ 'mon', 'tue', 'wed', 'thu', 'fri', 'sat', 'sun' ],\r\n\t\tmonths: [ 'january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december' ],\r\n\t\tmonths_abbrev: [ 'jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec' ],\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction tokenize_date( text )\r\n\t{\r\n\t\tlet tokens = [];\r\n\r\n\t\t// Split text into words.\r\n\t\tlet words = text.split( ' ' );\r\n\r\n\t\t// Convert words to tokens.\r\n\t\twords.forEach(\r\n\t\t\t( word, word_index ) =>\r\n\t\t\t{\r\n\t\t\t\t// Remove punctuation\r\n\t\t\t\tif ( word.endsWith( ',' ) ) { word = word.substr( 0, word.length - 1 ); }\r\n\t\t\t\tif ( word.endsWith( '.' ) ) { word = word.substr( 0, word.length - 1 ); }\r\n\r\n\t\t\t\t// Split up date formats\r\n\t\t\t\tif ( word.includes( '/' ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet parts = word.split( '/' );\r\n\t\t\t\t\tparts.forEach( part => tokens.push( part ) );\r\n\t\t\t\t}\r\n\t\t\t\telse if ( word.includes( '-' ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( word.startsWith( '-' ) || word.startsWith( 'utc-' ) || word.startsWith( 'gmt-' ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Treat as a time zone offset\r\n\t\t\t\t\t\ttokens.push( word );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Treat as a date\r\n\t\t\t\t\t\tlet parts = word.split( '-' );\r\n\t\t\t\t\t\tparts.forEach( part => tokens.push( part ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if ( word.includes( ',' ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet parts = word.split( ',' );\r\n\t\t\t\t\tparts.forEach( part => tokens.push( part ) );\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\ttokens.push( word );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Return tokens.\r\n\t\treturn tokens;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction tokens2symbols( tokens )\r\n\t{\r\n\t\tlet symbols = [];\r\n\t\ttokens.forEach(\r\n\t\t\t( token, token_index ) =>\r\n\t\t\t{\r\n\r\n\t\t\t\t// Check for time zone.\r\n\t\t\t\tif ( token.startsWith( '+' ) || token.startsWith( 'utc+' ) || token.startsWith( 'gmt+' ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tsymbols.push( { type: 'zone', value: token } );\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif ( token.startsWith( '-' ) || token.startsWith( 'utc-' ) || token.startsWith( 'gmt-' ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tsymbols.push( { type: 'zone', value: token } );\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check for universal time format.\r\n\t\t\t\tif ( token.includes( ':' ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tsymbols.push( { type: 'time', value: token } );\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check for month names.\r\n\t\t\t\tif ( REFS.months.includes( token ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet index = REFS.months.indexOf( token ) + 1;\r\n\t\t\t\t\ttoken = '' + index;\r\n\t\t\t\t\tif ( index < 10 ) { token = '0' + token; }\r\n\t\t\t\t\tsymbols.push( { type: 'month', value: token } );\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif ( REFS.months_abbrev.includes( token ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet index = REFS.months_abbrev.indexOf( token ) + 1;\r\n\t\t\t\t\ttoken = '' + index;\r\n\t\t\t\t\tif ( index < 10 ) { token = '0' + token; }\r\n\t\t\t\t\tsymbols.push( { type: 'month', value: token } );\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check for numeric\r\n\t\t\t\tif ( !isNaN( Number( token ) ) )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( token.length <= 2 )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( token.length === 1 ) { token = '0' + token; }\r\n\t\t\t\t\t\tsymbols.push( { type: 'day-or-month', value: token } );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse if ( token.length === 4 )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsymbols.push( { type: 'year', value: token } );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsymbols.push( { type: 'number', value: token } );\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tsymbols.push( { type: 'text', value: token } );\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Return the symbols.\r\n\t\treturn symbols;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction symbols2date( symbols, AssumeTimeZone )\r\n\t{\r\n\t\tlet fields =\r\n\t\t{\r\n\t\t\tyear: null,\r\n\t\t\tmonth: null,\r\n\t\t\tday: null,\r\n\t\t\ttime: null,\r\n\t\t\tzone: null,\r\n\t\t};\r\n\r\n\t\t// The first picks out the things we are pretty sure of.\r\n\t\tsymbols.forEach(\r\n\t\t\t( symbol ) =>\r\n\t\t\t{\r\n\t\t\t\tif ( symbol.type === 'year' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( fields.year ) { return; }\r\n\t\t\t\t\tfields.year = symbol.value;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( symbol.type === 'month' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( fields.month ) { return; }\r\n\t\t\t\t\tfields.month = symbol.value;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( symbol.type === 'time' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( fields.time ) { return; }\r\n\t\t\t\t\tfields.time = symbol.value;\r\n\t\t\t\t}\r\n\t\t\t\telse if ( symbol.type === 'zone' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( fields.zone ) { return; }\r\n\t\t\t\t\tfields.zone = symbol.value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// We go again to try to determine month and day.\r\n\t\tsymbols.forEach(\r\n\t\t\t( symbol ) =>\r\n\t\t\t{\r\n\t\t\t\tif ( symbol.type === 'day-or-month' )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( fields.day && fields.month ) { return; }\r\n\t\t\t\t\tif ( fields.month )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfields.day = symbol.value;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfields.month = symbol.value;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\t// Validate our date fields.\r\n\t\tif ( !fields.year ) { return null; }\r\n\t\tif ( !fields.month ) { return null; }\r\n\t\tif ( !fields.day ) { return null; }\r\n\t\tif ( !fields.time ) { fields.time = '00:00:00'; }\r\n\t\tif ( !fields.zone ) { fields.zone = AssumeTimeZone; }\r\n\r\n\t\t// Try to fix timezone offsets.\r\n\t\tif ( fields.zone )\r\n\t\t{\r\n\t\t\tlet zone = fields.zone;\r\n\r\n\t\t\t// Find the offset and direction.\r\n\t\t\tlet offset = '';\r\n\t\t\tlet sign = '';\r\n\t\t\tlet sign_index = -1;\r\n\t\t\t// - sign\r\n\t\t\tif ( zone.includes( '-' ) )\r\n\t\t\t{\r\n\t\t\t\tsign = '-';\r\n\t\t\t\tsign_index = zone.indexOf( '-' );\r\n\t\t\t\toffset = zone.substr( sign_index + 1 );\r\n\t\t\t}\r\n\t\t\telse if ( zone.includes( '+' ) )\r\n\t\t\t{\r\n\t\t\t\tsign = '+';\r\n\t\t\t\tsign_index = zone.indexOf( '+' );\r\n\t\t\t\toffset = zone.substr( sign_index + 1 );\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tsign = '+';\r\n\t\t\t\toffset = zone;\r\n\t\t\t}\r\n\t\t\t// - offset\r\n\t\t\tif ( offset.includes( ':' ) )\r\n\t\t\t{\r\n\t\t\t\toffset = offset.replace( ':', '' );\r\n\t\t\t}\r\n\t\t\tif ( offset.length > 4 ) { offset = offset.substr( 0, 4 ); } // e.g. +0500!@#\r\n\t\t\tif ( offset.length === 1 ) { offset = `0${offset}00`; } // e.g. -5\r\n\t\t\telse if ( offset.length === 2 ) { offset = `${offset}00`; } // e.g. -12\r\n\t\t\telse if ( offset.length === 3 ) { offset = `0${offset}`; } // e.g. -5:30\r\n\t\t\t// Reconstruct the zone.\r\n\t\t\tif ( offset.length === 4 )\r\n\t\t\t{\r\n\t\t\t\tfields.zone = `${sign}${offset}`;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfields.zone = AssumeTimeZone;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// Convert what we have with javascript date parsing.\r\n\t\tlet text = `${fields.year}-${fields.month}-${fields.day} ${fields.time} ${fields.zone}`;\r\n\t\tlet date = null;\r\n\t\ttry { date = new Date( text ); }\r\n\t\tcatch ( e ) { }\r\n\t\treturn date;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\tfunction get_date_parts( JsDate, TimeZoneOffset = '+0000' )\r\n\t{\r\n\t\tlet datetime_parts =\r\n\t\t{\r\n\t\t\tdate: null,\r\n\t\t\tyear: 0,\r\n\t\t\tmonth_num: 0,\r\n\t\t\tmonth_name: '',\r\n\t\t\tday_of_month: 0,\r\n\t\t\tday_of_week: 0,\r\n\t\t\tday_name: '',\r\n\t\t\thours: 0,\r\n\t\t\tminutes: 0,\r\n\t\t\tseconds: 0,\r\n\t\t\tmilliseconds: 0,\r\n\t\t\ttimezone_offset: ''\r\n\t\t};\r\n\t\tif ( !JsDate ) { return datetime_parts; }\r\n\t\tif ( isNaN( JsDate.getTime() ) ) { return datetime_parts; }\r\n\r\n\t\tdatetime_parts.date = new Date( JsDate.getTime() );\r\n\t\tdatetime_parts.year = datetime_parts.date.getFullYear();\r\n\t\tdatetime_parts.month_num = datetime_parts.date.getMonth();\r\n\t\tdatetime_parts.month_name = REFS.months[ datetime_parts.month_num ];\r\n\t\tdatetime_parts.day_of_month = datetime_parts.date.getDate();\r\n\t\tdatetime_parts.day_of_week = datetime_parts.date.getDay();\r\n\t\tif ( datetime_parts.day_of_week === 0 ) { datetime_parts.day_of_week = 7; }\r\n\t\tdatetime_parts.day_name = REFS.day_of_week[ datetime_parts.day_of_week - 1 ];\r\n\t\tdatetime_parts.hours = datetime_parts.date.getHours();\r\n\t\tdatetime_parts.minutes = datetime_parts.date.getMinutes();\r\n\t\tdatetime_parts.seconds = datetime_parts.date.getSeconds();\r\n\t\tdatetime_parts.milliseconds = datetime_parts.date.getMilliseconds();\r\n\t\tdatetime_parts.timezone_offset = TimeZoneOffset;\r\n\r\n\t\treturn datetime_parts;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tDateParse: DateParse,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '800',\r\n\tname: 'System',\r\n\ttype: 'namespace',\r\n\tsummary: 'File system and process functions. (nodejs only)',\r\n};\r\n\r\n\r\n//-start-jsdoc---------------------------------------------------------\r\n/**\n * @public\n * @namespace System\n * @summary File system and process functions. (nodejs only)\n*/\n//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\r\n\t\t// File System\r\n\t\tAsyncVisitFiles: require( './810-System.AsyncVisitFiles.js' )( Liquicode ).AsyncVisitFiles,\r\n\t\tVisitFiles: require( './810-System.VisitFiles.js' )( Liquicode ).VisitFiles,\r\n\t\tCountFiles: require( './811-System.CountFiles.js' )( Liquicode ).CountFiles,\r\n\t\tCountFolders: require( './812-System.CountFolders.js' )( Liquicode ).CountFolders,\r\n\t\tCopyFolder: require( './813-System.CopyFolder.js' )( Liquicode ).CopyFolder,\r\n\t\tDeleteFolder: require( './814-System.DeleteFolder.js' )( Liquicode ).DeleteFolder,\r\n\t\tEmptyFolder: require( './815-System.EmptyFolder.js' )( Liquicode ).EmptyFolder,\r\n\t\tWithFileText: require( './816-System.WithFileText.js' )( Liquicode ).WithFileText,\r\n\r\n\t\t// Process\r\n\t\tAsyncSleep: require( './820-System.AsyncSleep.js' )( Liquicode ).AsyncSleep,\r\n\t\tExecuteProcess: require( './821-System.ExecuteProcess.js' )( Liquicode ).ExecuteProcess,\r\n\t\tAsyncExecuteProcess: require( './822-System.AsyncExecuteProcess.js' )( Liquicode ).AsyncExecuteProcess,\r\n\t\tStartProcess: require( './823-System.StartProcess.js' )( Liquicode ).StartProcess,\r\n\t\tStopProcess: require( './824-System.StopProcess.js' )( Liquicode ).StopProcess,\r\n\r\n\t\t// Docker\r\n\t\tContainerStatus: require( './830-System.ContainerStatus.js' )( Liquicode ).ContainerStatus,\r\n\t\tRunContainer: require( './831-System.RunContainer.js' )( Liquicode ).RunContainer,\r\n\t\tStartContainer: require( './832-System.StartContainer.js' )( Liquicode ).StartContainer,\r\n\t\tStopContainer: require( './833-System.StopContainer.js' )( Liquicode ).StopContainer,\r\n\t\tKillContainer: require( './834-System.KillContainer.js' )( Liquicode ).KillContainer,\r\n\r\n\t};\r\n};\r\n\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '810',\r\n\tmember_of: 'System',\r\n\tname: 'AsyncVisitFiles',\r\n\ttype: 'function',\r\n\treturns: '*',\r\n\tdescription: `\r\nScans a folder and calls the Visitor callback function for each folder/file encountered.\r\n\r\nThe \\`FilePattern\\` parameter is optional and can be a wildcard type string.\r\nFor example, to visit all text files, you can pass '*.txt'.\r\nIf \\`FilePattern\\` is not empty, then the callback will not be called for folders.\r\n\r\nThe Visitor callback function takes two parameters \\`Visitor( Path, Filename )\\`.\r\nIf the Visitor callback returns a value, then the visitation process is halted\r\nand that value is returned by the \\`VisitFiles\\` function.\r\nThe Visitor callback is called for each file encountered and for each folder encountered.\r\nWhen called for a folder, the \\`Filename\\` parameter will be null.\r\nThe Visitor callback function can be either synchronous or asymchronous.\r\n`,\r\n\tParameters: {\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tFilePattern: {\r\n\t\t\tname: 'FilePattern',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tRecurse: {\r\n\t\t\tname: 'Recurse',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t\tVisitor: {\r\n\t\t\tname: 'Visitor',\r\n\t\t\ttype: 'function',\r\n\t\t\tdescription: 'Function to be called for each folder and file: Visitor( Path, Filename )',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: null,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function AsyncVisitFiles\n\t * @returns {*}\n\t * @description\n\t * \nScans a folder and calls the Visitor callback function for each folder/file encountered.\n\nThe `FilePattern` parameter is optional and can be a wildcard type string.\nFor example, to visit all text files, you can pass '*.txt'.\nIf `FilePattern` is not empty, then the callback will not be called for folders.\n\nThe Visitor callback function takes two parameters `Visitor( Path, Filename )`.\nIf the Visitor callback returns a value, then the visitation process is halted\nand that value is returned by the `VisitFiles` function.\nThe Visitor callback is called for each file encountered and for each folder encountered.\nWhen called for a folder, the `Filename` parameter will be null.\nThe Visitor callback function can be either synchronous or asymchronous.\n\n\t * @param {string} StartFolder\n\t * @param {string} [FilePattern]\n\t * @param {boolean} [Recurse]\n\t * @param {function} [Visitor]\n\t * Function to be called for each folder and file: Visitor( Path, Filename )\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_PATH = require( 'path' );\r\n\r\n\r\n\tasync function AsyncVisitFiles( StartFolder, FilePattern, Recurse, Visitor ) \r\n\t{\r\n\t\tStartFolder = Liquicode.Types.Coerce( StartFolder ).ToString();\r\n\t\tFilePattern = Liquicode.Types.Coerce( FilePattern ).ToString();\r\n\t\tRecurse = Liquicode.Types.Coerce( Recurse ).ToBoolean();\r\n\t\t// Visitor = Liquicode.Types.Coerce( Visitor, Schema.Parameters.Visitor , { coerce_values: true, throw_errors: true });\r\n\r\n\t\tif ( !LIB_FS.existsSync( StartFolder ) ) { return; }\r\n\t\t// let count = 0;\r\n\t\tlet elements = LIB_FS.readdirSync( StartFolder );\r\n\t\tfor ( let element_index = 0; element_index < elements.length; element_index++ )\r\n\t\t{\r\n\t\t\tlet element = elements[ element_index ];\r\n\t\t\tlet from_path = LIB_PATH.join( StartFolder, element );\r\n\t\t\tif ( LIB_FS.lstatSync( from_path ).isFile() )\r\n\t\t\t{\r\n\t\t\t\tif ( FilePattern ) \r\n\t\t\t\t{\r\n\t\t\t\t\tif ( Liquicode.Text.Matches( element, FilePattern ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// if ( Visitor ) { Visitor( StartFolder, element ); }\r\n\t\t\t\t\t\t// count++;\r\n\t\t\t\t\t\tif ( Visitor ) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet value = await Visitor( StartFolder, element );\r\n\t\t\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// if ( Visitor ) { Visitor( StartFolder, element ); }\r\n\t\t\t\t\t// count++;\r\n\t\t\t\t\tif ( Visitor ) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet value = await Visitor( StartFolder, element );\r\n\t\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if ( LIB_FS.lstatSync( from_path ).isDirectory() )\r\n\t\t\t{\r\n\t\t\t\tif ( !FilePattern ) \r\n\t\t\t\t{\r\n\t\t\t\t\t// if ( Visitor ) { Visitor( from_path, null ); }\r\n\t\t\t\t\t// count++;\r\n\t\t\t\t\tif ( Visitor ) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet value = await Visitor( from_path, null );\r\n\t\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( Recurse )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = AsyncVisitFiles( from_path, FilePattern, Recurse, Visitor );\r\n\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tAsyncVisitFiles: AsyncVisitFiles,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '810',\r\n\tmember_of: 'System',\r\n\tname: 'VisitFiles',\r\n\ttype: 'function',\r\n\treturns: '*',\r\n\tdescription: `\r\nScans a folder and calls the Visitor callback function for each folder/file encountered.\r\n\r\nThe \\`FilePattern\\` parameter is optional and can be a wildcard type string.\r\nFor example, to visit all text files, you can pass '*.txt'.\r\nIf \\`FilePattern\\` is not empty, then the callback will not be called for folders.\r\n\r\nThe Visitor callback function takes two parameters \\`Visitor( Path, Filename )\\`.\r\nIf the Visitor callback returns a value, then the visitation process is halted\r\nand that value is returned by the \\`VisitFiles\\` function.\r\nThe Visitor callback is called for each file encountered and for each folder encountered.\r\nWhen called for a folder, the \\`Filename\\` parameter will be null.\r\nThe Visitor callback function must be synchronous.\r\n`,\r\n\tParameters: {\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tFilePattern: {\r\n\t\t\tname: 'FilePattern',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '',\r\n\t\t},\r\n\t\tRecurse: {\r\n\t\t\tname: 'Recurse',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t\tVisitor: {\r\n\t\t\tname: 'Visitor',\r\n\t\t\ttype: 'function',\r\n\t\t\tdescription: 'Function to be called for each folder and file: Visitor( Path, Filename )',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: null,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function VisitFiles\n\t * @returns {*}\n\t * @description\n\t * \nScans a folder and calls the Visitor callback function for each folder/file encountered.\n\nThe `FilePattern` parameter is optional and can be a wildcard type string.\nFor example, to visit all text files, you can pass '*.txt'.\nIf `FilePattern` is not empty, then the callback will not be called for folders.\n\nThe Visitor callback function takes two parameters `Visitor( Path, Filename )`.\nIf the Visitor callback returns a value, then the visitation process is halted\nand that value is returned by the `VisitFiles` function.\nThe Visitor callback is called for each file encountered and for each folder encountered.\nWhen called for a folder, the `Filename` parameter will be null.\nThe Visitor callback function must be synchronous.\n\n\t * @param {string} StartFolder\n\t * @param {string} [FilePattern]\n\t * @param {boolean} [Recurse]\n\t * @param {function} [Visitor]\n\t * Function to be called for each folder and file: Visitor( Path, Filename )\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_PATH = require( 'path' );\r\n\r\n\r\n\tfunction VisitFiles( StartFolder, FilePattern, Recurse, Visitor ) \r\n\t{\r\n\t\tStartFolder = Liquicode.Types.Coerce( StartFolder ).ToString();\r\n\t\tFilePattern = Liquicode.Types.Coerce( FilePattern ).ToString();\r\n\t\tRecurse = Liquicode.Types.Coerce( Recurse ).ToBoolean();\r\n\t\t// Visitor = Liquicode.Types.Coerce( Visitor, Schema.Parameters.Visitor , { coerce_values: true, throw_errors: true });\r\n\r\n\t\tif ( !LIB_FS.existsSync( StartFolder ) ) { return; }\r\n\t\t// let count = 0;\r\n\t\tlet elements = LIB_FS.readdirSync( StartFolder );\r\n\t\tfor ( let element_index = 0; element_index < elements.length; element_index++ )\r\n\t\t{\r\n\t\t\tlet element = elements[ element_index ];\r\n\t\t\tlet from_path = LIB_PATH.join( StartFolder, element );\r\n\t\t\tif ( LIB_FS.lstatSync( from_path ).isFile() )\r\n\t\t\t{\r\n\t\t\t\tif ( FilePattern ) \r\n\t\t\t\t{\r\n\t\t\t\t\tif ( Liquicode.Text.Matches( element, FilePattern ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// if ( Visitor ) { Visitor( StartFolder, element ); }\r\n\t\t\t\t\t\t// count++;\r\n\t\t\t\t\t\tif ( Visitor ) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet value = Visitor( StartFolder, element );\r\n\t\t\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// if ( Visitor ) { Visitor( StartFolder, element ); }\r\n\t\t\t\t\t// count++;\r\n\t\t\t\t\tif ( Visitor ) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet value = Visitor( StartFolder, element );\r\n\t\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if ( LIB_FS.lstatSync( from_path ).isDirectory() )\r\n\t\t\t{\r\n\t\t\t\tif ( !FilePattern ) \r\n\t\t\t\t{\r\n\t\t\t\t\t// if ( Visitor ) { Visitor( from_path, null ); }\r\n\t\t\t\t\t// count++;\r\n\t\t\t\t\tif ( Visitor ) \r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet value = Visitor( from_path, null );\r\n\t\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif ( Recurse )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = VisitFiles( from_path, FilePattern, Recurse, Visitor );\r\n\t\t\t\t\tif ( value !== undefined ) { return value; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tVisitFiles: VisitFiles,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '811',\r\n\tmember_of: 'System',\r\n\tname: 'CountFiles',\r\n\ttype: 'function',\r\n\treturns: 'number',\r\n\tdescription: [\r\n\t\t'Scans a folder and calls the Visitor callback function for each folder/file encountered.',\r\n\t\t'Returns the number of folders/files visited.',\r\n\t],\r\n\tParameters: {\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tFilePattern: {\r\n\t\t\tname: 'FilePattern',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '*',\r\n\t\t},\r\n\t\tRecurse: {\r\n\t\t\tname: 'Recurse',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function CountFiles\n\t * @returns {number}\n\t * @description\n\t * Scans a folder and calls the Visitor callback function for each folder/file encountered.\n\t * Returns the number of folders/files visited.\n\t * @param {string} StartFolder\n\t * @param {string} [FilePattern=\"*\"]\n\t * @param {boolean} [Recurse]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction CountFiles( StartFolder, FilePattern, Recurse ) \r\n\t{\r\n\t\tStartFolder = Liquicode.Types.Coerce( StartFolder ).ToString();\r\n\t\tFilePattern = Liquicode.Types.Coerce( FilePattern ).ToString();\r\n\t\tRecurse = Liquicode.Types.Coerce( Recurse ).ToBoolean();\r\n\r\n\t\tlet count = Liquicode.System.VisitFiles( StartFolder, FilePattern, Recurse );\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tCountFiles: CountFiles,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '812',\r\n\tmember_of: 'System',\r\n\tname: 'CountFolders',\r\n\ttype: 'function',\r\n\treturns: 'number',\r\n\tdescription: [\r\n\t\t'Scans a folder and calls the Visitor callback function for each folder/file encountered.',\r\n\t\t'Returns the number of folders/files visited.',\r\n\t],\r\n\tParameters: {\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tRecurse: {\r\n\t\t\tname: 'Recurse',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function CountFolders\n\t * @returns {number}\n\t * @description\n\t * Scans a folder and calls the Visitor callback function for each folder/file encountered.\n\t * Returns the number of folders/files visited.\n\t * @param {string} StartFolder\n\t * @param {boolean} [Recurse]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction CountFolders( StartFolder, Recurse ) \r\n\t{\r\n\t\tStartFolder = Liquicode.Types.Coerce( StartFolder ).ToString();\r\n\t\tRecurse = Liquicode.Types.Coerce( Recurse ).ToBoolean();\r\n\r\n\t\tlet folder_count = 0;\r\n\t\tLiquicode.System.VisitFiles( StartFolder, '', Recurse,\r\n\t\t\tfunction ( Folder, Filename )\r\n\t\t\t{\r\n\t\t\t\tif ( Folder && !Filename )\r\n\t\t\t\t{\r\n\t\t\t\t\tfolder_count++;\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\treturn folder_count;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tCountFolders: CountFolders,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '813',\r\n\tmember_of: 'System',\r\n\tname: 'CopyFolder',\r\n\ttype: 'function',\r\n\treturns: 'number',\r\n\tdescription: [\r\n\t\t'Copies files from one folder to another.',\r\n\t\t'Returns the number of files copied.',\r\n\t],\r\n\tParameters: {\r\n\t\tFromFolder: {\r\n\t\t\tname: 'FromFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tToFolder: {\r\n\t\t\tname: 'ToFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tFilePattern: {\r\n\t\t\tname: 'FilePattern',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: '*',\r\n\t\t},\r\n\t\tOverwrite: {\r\n\t\t\tname: 'Overwrite',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t\tRecurse: {\r\n\t\t\tname: 'Recurse',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function CopyFolder\n\t * @returns {number}\n\t * @description\n\t * Copies files from one folder to another.\n\t * Returns the number of files copied.\n\t * @param {string} FromFolder\n\t * @param {string} ToFolder\n\t * @param {string} [FilePattern=\"*\"]\n\t * @param {boolean} [Overwrite]\n\t * @param {boolean} [Recurse]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_PATH = require( 'path' );\r\n\r\n\r\n\tfunction CopyFolder( FromFolder, ToFolder, FilePattern, Overwrite, Recurse ) \r\n\t{\r\n\t\tFromFolder = Liquicode.Types.Coerce( FromFolder ).ToString();\r\n\t\tToFolder = Liquicode.Types.Coerce( ToFolder ).ToString();\r\n\t\tFilePattern = Liquicode.Types.Coerce( FilePattern ).ToString();\r\n\t\tOverwrite = Liquicode.Types.Coerce( Overwrite ).ToBoolean();\r\n\t\tRecurse = Liquicode.Types.Coerce( Recurse ).ToBoolean();\r\n\r\n\t\tif ( !LIB_FS.existsSync( FromFolder ) ) { return 0; }\r\n\t\tLIB_FS.mkdirSync( ToFolder, { recursive: true } );\r\n\t\tlet count = 0;\r\n\t\tlet elements = LIB_FS.readdirSync( FromFolder );\r\n\t\tfor ( let element_index = 0; element_index < elements.length; element_index++ )\r\n\t\t{\r\n\t\t\tlet element = elements[ element_index ];\r\n\t\t\tlet from_path = LIB_PATH.join( FromFolder, element );\r\n\t\t\tlet to_path = LIB_PATH.join( ToFolder, element );\r\n\t\t\tif ( LIB_FS.lstatSync( from_path ).isFile() )\r\n\t\t\t{\r\n\t\t\t\tif ( !LIB_FS.existsSync( to_path ) || Overwrite ) \r\n\t\t\t\t{\r\n\t\t\t\t\tLIB_FS.copyFileSync( from_path, to_path );\r\n\t\t\t\t\tcount++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse if ( Recurse && LIB_FS.lstatSync( from_path ).isDirectory() )\r\n\t\t\t{\r\n\t\t\t\tcount += CopyFolder( from_path, to_path, Overwrite, Recurse );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tCopyFolder: CopyFolder,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '814',\r\n\tmember_of: 'System',\r\n\tname: 'DeleteFolder',\r\n\ttype: 'function',\r\n\treturns: 'number',\r\n\tdescription: [\r\n\t\t'Deletes a folder and all of its sub-folders and files.',\r\n\t\t'Returns the number of folders and files deleted.',\r\n\t],\r\n\tParameters: {\r\n\t\tFolder: {\r\n\t\t\tname: 'Folder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\t// FilePattern: {\r\n\t\t// \tname: 'FilePattern',\r\n\t\t// \ttype: 'string',\r\n\t\t// \trequired: false,\r\n\t\t// \tdefault: '',\r\n\t\t// },\r\n\t\tRecurse: {\r\n\t\t\tname: 'Recurse',\r\n\t\t\ttype: 'boolean',\r\n\t\t\trequired: false,\r\n\t\t\tdefault: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function DeleteFolder\n\t * @returns {number}\n\t * @description\n\t * Deletes a folder and all of its sub-folders and files.\n\t * Returns the number of folders and files deleted.\n\t * @param {string} Folder\n\t * @param {boolean} [Recurse]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_PATH = require( 'path' );\r\n\r\n\r\n\tfunction DeleteFolder( Folder, Recurse ) \r\n\t{\r\n\t\tFolder = Liquicode.Types.Coerce( Folder ).ToString();\r\n\t\tRecurse = Liquicode.Types.Coerce( Recurse ).ToBoolean();\r\n\r\n\t\tif ( !LIB_FS.existsSync( Folder ) ) { return 0; }\r\n\t\tlet count = 0;\r\n\t\tlet elements = LIB_FS.readdirSync( Folder );\r\n\t\tfor ( let element_index = 0; element_index < elements.length; element_index++ )\r\n\t\t{\r\n\t\t\tlet element = elements[ element_index ];\r\n\t\t\tlet from_path = LIB_PATH.join( Folder, element );\r\n\t\t\tif ( LIB_FS.lstatSync( from_path ).isFile() )\r\n\t\t\t{\r\n\t\t\t\tLIB_FS.unlinkSync( from_path );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\telse if ( Recurse && LIB_FS.lstatSync( from_path ).isDirectory() )\r\n\t\t\t{\r\n\t\t\t\tcount += DeleteFolder( from_path, Recurse );\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Delete this folder.\r\n\t\tif ( Recurse )\r\n\t\t{\r\n\t\t\tlet elements = LIB_FS.readdirSync( Folder );\r\n\t\t\tif ( !elements.length ) \r\n\t\t\t{\r\n\t\t\t\tLIB_FS.rmdirSync( Folder );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tDeleteFolder: DeleteFolder,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '815',\r\n\tmember_of: 'System',\r\n\tname: 'EmptyFolder',\r\n\ttype: 'function',\r\n\treturns: 'number',\r\n\treturn_description: 'Number of folders and files removed.',\r\n\tdescription: `\r\nEmpties a folder by removing all of its sub-folders and files.\r\n\r\nReturns the number of folders and files removed.\r\n`,\r\n\tParameters: {\r\n\t\tFolder: {\r\n\t\t\tname: 'Folder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function EmptyFolder\n\t * @returns {number}\n\t * @description\n\t * \nEmpties a folder by removing all of its sub-folders and files.\n\nReturns the number of folders and files removed.\n\n\t * @param {string} Folder\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_PATH = require( 'path' );\r\n\r\n\r\n\tfunction _EmptyFolder( Folder, Depth ) \r\n\t{\r\n\t\tlet count = 0;\r\n\t\tlet elements = LIB_FS.readdirSync( Folder );\r\n\t\tfor ( let element_index = 0; element_index < elements.length; element_index++ )\r\n\t\t{\r\n\t\t\tlet element = elements[ element_index ];\r\n\t\t\tlet from_path = LIB_PATH.join( Folder, element );\r\n\t\t\tif ( LIB_FS.lstatSync( from_path ).isFile() )\r\n\t\t\t{\r\n\t\t\t\tLIB_FS.unlinkSync( from_path );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t\telse if ( LIB_FS.lstatSync( from_path ).isDirectory() )\r\n\t\t\t{\r\n\t\t\t\tcount += _EmptyFolder( from_path, ( Depth + 1 ) );\r\n\t\t\t}\r\n\t\t}\r\n\t\t// Delete this folder.\r\n\t\tif ( Depth > 0 )\r\n\t\t{\r\n\t\t\tlet elements = LIB_FS.readdirSync( Folder );\r\n\t\t\tif ( !elements.length ) \r\n\t\t\t{\r\n\t\t\t\tLIB_FS.rmdirSync( Folder );\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\tfunction EmptyFolder( Folder ) \r\n\t{\r\n\t\tFolder = Liquicode.Types.Coerce( Folder ).ToString();\r\n\t\tif ( !LIB_FS.existsSync( Folder ) ) { return 0; }\r\n\t\tlet count = _EmptyFolder( Folder, 0 );\r\n\t\treturn count;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tEmptyFolder: EmptyFolder,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '816',\r\n\tmember_of: 'System',\r\n\tname: 'WithFileText',\r\n\ttype: 'function',\r\n\treturns: 'boolean',\r\n\treturns_description: 'False if no changes were made or True if changes were saved.',\r\n\tdescription: `\r\nLoads content from a file and passes it to a callback function for processing.\r\n\r\nThe callback function takes two parameters: Filename and Text.\r\nFilename is the Filename passed to \\`WithFileText\\` and Text is the content of that file.\r\nThe callback function is expected to return either \\`undefined\\` or \\`null\\` if no changes are made to the text.\r\nIf changes are made, the callback function can return the new text which will be saved back to Filename.\r\n\r\nIf the file content is changed during callback processing, then \\`WithFileText\\` will return True.\r\n`,\r\n\tParameters: {\r\n\t\tFilename: {\r\n\t\t\tname: 'Filename',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tFileTextCallback: {\r\n\t\t\tname: 'FileTextCallback',\r\n\t\t\ttype: 'function',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function WithFileText\n\t * @returns {boolean}\n\t * False if no changes were made or True if changes were saved.\n\t * @description\n\t * \nLoads content from a file and passes it to a callback function for processing.\n\nThe callback function takes two parameters: Filename and Text.\nFilename is the Filename passed to `WithFileText` and Text is the content of that file.\nThe callback function is expected to return either `undefined` or `null` if no changes are made to the text.\nIf changes are made, the callback function can return the new text which will be saved back to Filename.\n\nIf the file content is changed during callback processing, then `WithFileText` will return True.\n\n\t * @param {string} Filename\n\t * @param {function} FileTextCallback\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\r\n\r\n\tfunction WithFileText( Filename, FileTextCallback ) \r\n\t{\r\n\t\tlet text = LIB_FS.readFileSync( Filename, 'utf-8' );\r\n\t\tlet processed_text = FileTextCallback( Filename, text );\r\n\t\tif ( ( processed_text === undefined ) || ( processed_text === null ) ) { return false; }\r\n\t\tif ( typeof processed_text !== 'string' ) { throw new Error( `The return value from [FileTextCallback] must be either undefined, null, or a text string.` ); }\r\n\t\tif ( processed_text === text ) { return false; }\r\n\t\tLIB_FS.writeFileSync( Filename, processed_text );\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tWithFileText: WithFileText,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '820',\r\n\tmember_of: 'System',\r\n\tname: 'AsyncSleep',\r\n\ttype: 'function',\r\n\t// returns: 'number',\r\n\tdescription: ``,\r\n\tParameters: {\r\n\t\tMilliseconds: {\r\n\t\t\tname: 'Milliseconds',\r\n\t\t\ttype: 'number',\r\n\t\t\tformat: 'integer',\r\n\t\t\t// required: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function AsyncSleep\n\t * @param {number} [Milliseconds]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction AsyncSleep( Milliseconds ) \r\n\t{\r\n\t\tMilliseconds = Liquicode.Types.Coerce( Milliseconds ).ToNumber();\r\n\r\n\t\treturn new Promise( resolve => setTimeout( resolve, Milliseconds ) );\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tAsyncSleep: AsyncSleep,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '821',\r\n\tmember_of: 'System',\r\n\tname: 'ExecuteProcess',\r\n\ttype: 'function',\r\n\t// returns: 'number',\r\n\tdescription: ``,\r\n\tParameters: {\r\n\t\tCommand: {\r\n\t\t\tname: 'Command',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tEnvironment: {\r\n\t\t\tname: 'Environment',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ExecuteProcess\n\t * @param {string} Command\n\t * @param {object} [Environment]\n\t * @param {string} [StartFolder]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_CHILD_PROCESS = require( 'child_process' );\r\n\r\n\r\n\tfunction ExecuteProcess( Command, Environment, StartFolder ) \r\n\t{\r\n\t\tlet options = {\r\n\t\t\tencoding: 'utf-8',\r\n\t\t};\r\n\t\tif ( Environment && Object.keys( Environment ) ) { options.env = Environment; }\r\n\t\tif ( StartFolder && LIB_FS.existsSync( StartFolder ) ) { options.cwd = StartFolder; }\r\n\r\n\t\tlet result = {\r\n\t\t\tresult: '',\r\n\t\t\terror: '',\r\n\t\t\tstdout: '',\r\n\t\t\tstderror: '',\r\n\t\t};\r\n\t\ttry\r\n\t\t{\r\n\t\t\tresult.result =\r\n\t\t\t\tLIB_CHILD_PROCESS.execSync( Command, options,\r\n\t\t\t\t\t( error, stdout, stderror ) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult.error = error;\r\n\t\t\t\t\t\tresult.stdout = stdout;\r\n\t\t\t\t\t\tresult.stderror = stderror;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t}\r\n\t\tcatch ( error )\r\n\t\t{\r\n\t\t\tresult.error = error.message;\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tExecuteProcess: ExecuteProcess,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '822',\r\n\tmember_of: 'System',\r\n\tname: 'AsyncExecuteProcess',\r\n\ttype: 'function',\r\n\t// returns: 'number',\r\n\tdescription: ``,\r\n\tParameters: {\r\n\t\tCommand: {\r\n\t\t\tname: 'Command',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tEnvironment: {\r\n\t\t\tname: 'Environment',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function AsyncExecuteProcess\n\t * @param {string} Command\n\t * @param {object} [Environment]\n\t * @param {string} [StartFolder]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_CHILD_PROCESS = require( 'child_process' );\r\n\r\n\r\n\tfunction AsyncExecuteProcess( Command, Environment, StartFolder ) \r\n\t{\r\n\t\treturn new Promise(\r\n\t\t\t( resolve, reject ) =>\r\n\t\t\t{\r\n\t\t\t\tresolve( Liquicode.System.ExecuteProcess( Command, Environment, StartFolder ) );\r\n\t\t\t} );\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tAsyncExecuteProcess: AsyncExecuteProcess,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '823',\r\n\tmember_of: 'System',\r\n\tname: 'StartProcess',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Starts a new process and returns the ProcessID.`,\r\n\tParameters: {\r\n\t\tCommand: {\r\n\t\t\tname: 'Command',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tEnvironment: {\r\n\t\t\tname: 'Environment',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t\tStartFolder: {\r\n\t\t\tname: 'StartFolder',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function StartProcess\n\t * @returns {string}\n\t * @description\n\t * Starts a new process and returns the ProcessID.\n\t * @param {string} Command\n\t * @param {object} [Environment]\n\t * @param {string} [StartFolder]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_FS = require( 'fs' );\r\n\tconst LIB_CHILD_PROCESS = require( 'child_process' );\r\n\r\n\r\n\tfunction StartProcess( Command, Environment, StartFolder ) \r\n\t{\r\n\t\tlet options = {};\r\n\t\tif ( Environment && Object.keys( Environment ) ) { options.env = Environment; }\r\n\t\tif ( StartFolder && LIB_FS.existsSync( StartFolder ) ) { options.cwd = StartFolder; }\r\n\t\tlet child_process = LIB_CHILD_PROCESS.exec( Command, options );\r\n\t\treturn child_process.pid;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tStartProcess: StartProcess,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '824',\r\n\tmember_of: 'System',\r\n\tname: 'StopProcess',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Stops a running process by its ProcessID.`,\r\n\tParameters: {\r\n\t\tProcessID: {\r\n\t\t\tname: 'ProcessID',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function StopProcess\n\t * @returns {string}\n\t * @description\n\t * Stops a running process by its ProcessID.\n\t * @param {string} ProcessID\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction StopProcess( ProcessID ) \r\n\t{\r\n\t\tprocess.kill( ProcessID, 'SIGINT' );\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tStopProcess: StopProcess,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '830',\r\n\tmember_of: 'System',\r\n\tname: 'ContainerStatus',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Gets the status of a running Docker Container.`,\r\n\tParameters: {\r\n\t\tContainerID: {\r\n\t\t\tname: 'ContainerID',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function ContainerStatus\n\t * @returns {string}\n\t * @description\n\t * Gets the status of a running Docker Container.\n\t * @param {string} ContainerID\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction ContainerStatus( ContainerID ) \r\n\t{\r\n\t\tlet command_line = `docker inspect ${ContainerID}`;\r\n\t\tlet result = Liquicode.System.ExecuteProcess( command_line );\r\n\t\tif ( result.error ) \r\n\t\t{\r\n\t\t\t// if ( result.error === `Command failed: docker inspect ${ContainerID}\\nError: No such object: ${ContainerID}\\n` ) { return null; }\r\n\t\t\tif ( result.error.indexOf( 'Error: No such object' ) ) { return null; }\r\n\t\t\tthrow new Error( result.error );\r\n\t\t}\r\n\t\tlet status = JSON.parse( result.result );\r\n\t\tif ( Array.isArray( status ) && status.length )\r\n\t\t{\r\n\t\t\tstatus = status[ 0 ];\r\n\t\t}\r\n\t\treturn status;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tContainerStatus: ContainerStatus,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '831',\r\n\tmember_of: 'System',\r\n\tname: 'RunContainer',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `\r\nRuns a Docker Container.\r\n\r\nOptions Parameter:\r\n~~~javascript\r\n{\r\n\tname: '',           // Name of the container. Defaults to random name.\r\n\thostname: '',       // Hostname for the container.\r\n\tnetwork: '',        // Name of docker network for the container to use.\r\n\tports: [],          // Array of port object { localhost: 80, container: 80 }\r\n\tvolumes: [],        // Array of volume object { localhost: '/path', container: '/path' }\r\n\tenvironment: {},    // Environment variables and values.\r\n}\r\n~~~\r\n\r\nExample:\r\n~~~javascript\r\nlet container_id = Liquicode.RunContainer( 'mongo:latest',\r\n\t{\r\n\t\tname: 'mongo-server',\r\n\t\tports: [ { localhost: 27017, container: 27017 } ],\r\n\t} );\r\n~~~\r\n\r\n`,\r\n\tParameters: {\r\n\t\tImageName: {\r\n\t\t\tname: 'ImageName',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t\tOptions: {\r\n\t\t\tname: 'Options',\r\n\t\t\ttype: 'object',\r\n\t\t\trequired: false,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function RunContainer\n\t * @returns {string}\n\t * @description\n\t * \nRuns a Docker Container.\n\nOptions Parameter:\n~~~javascript\n{\n\tname: '',           // Name of the container. Defaults to random name.\n\thostname: '',       // Hostname for the container.\n\tnetwork: '',        // Name of docker network for the container to use.\n\tports: [],          // Array of port object { localhost: 80, container: 80 }\n\tvolumes: [],        // Array of volume object { localhost: '/path', container: '/path' }\n\tenvironment: {},    // Environment variables and values.\n}\n~~~\n\nExample:\n~~~javascript\nlet container_id = Liquicode.RunContainer( 'mongo:latest',\n\t{\n\t\tname: 'mongo-server',\n\t\tports: [ { localhost: 27017, container: 27017 } ],\n\t} );\n~~~\n\n\n\t * @param {string} ImageName\n\t * @param {object} [Options]\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction RunContainer( ImageName, Options ) \r\n\t{\r\n\t\tlet command_line = `docker run --rm -d`;\r\n\t\tif ( Options )\r\n\t\t{\r\n\t\t\t// Container Name\r\n\t\t\tif ( Options.name )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Options.name !== 'string' ) { throw new Error( `Options.name must be a string.` ); }\r\n\t\t\t\tcommand_line += ` --name ${Options.name}`;\r\n\t\t\t}\r\n\r\n\t\t\t// Hostname\r\n\t\t\tif ( Options.hostname )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Options.hostname !== 'string' ) { throw new Error( `Options.hostname must be a string.` ); }\r\n\t\t\t\tcommand_line += ` --hostname ${Options.hostname}`;\r\n\t\t\t}\r\n\r\n\t\t\t// Network\r\n\t\t\tif ( Options.network )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Options.network !== 'string' ) { throw new Error( `Options.network must be a string.` ); }\r\n\t\t\t\tcommand_line += ` --network=\"${Options.network}\"`;\r\n\t\t\t}\r\n\r\n\t\t\t// Publish Ports\r\n\t\t\tif ( Options.ports )\r\n\t\t\t{\r\n\t\t\t\tif ( !Array.isArray( Options.ports ) ) { throw new Error( `Options.ports must be an array of port definitions.` ); }\r\n\t\t\t\tfor ( let index = 0; index < Options.ports.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet port = Options.ports[ index ];\r\n\t\t\t\t\tcommand_line += ` -p ${port.localhost}:${port.container}`;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Shared Volumes\r\n\t\t\tif ( Options.volumes )\r\n\t\t\t{\r\n\t\t\t\tif ( !Array.isArray( Options.volumes ) ) { throw new Error( `Options.volumes must be an array of volume definitions.` ); }\r\n\t\t\t\tfor ( let index = 0; index < Options.volumes.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet volume = Options.volumes[ index ];\r\n\t\t\t\t\tcommand_line += ` -v ${volume.localhost}:${volume.container}`;\r\n\t\t\t\t\tif ( volume.readonly ) { command_line += `:ro`; }\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// Environment Variables\r\n\t\t\tif ( Options.environment )\r\n\t\t\t{\r\n\t\t\t\tif ( typeof Options.environment !== 'object' ) { throw new Error( `Options.environment must be an object.` ); }\r\n\t\t\t\tlet keys = Object.keys( Options.environment );\r\n\t\t\t\tfor ( let index = 0; index < keys.length; index++ )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet name = keys[ index ];\r\n\t\t\t\t\tcommand_line += ` -e \"${name}=${Options.environment[ name ]}\"`;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Image Name\r\n\t\tcommand_line += ` ${ImageName}`;\r\n\t\t// Initial Command\r\n\t\tif ( Options && ( typeof Options.command === 'string' ) )\r\n\t\t{\r\n\t\t\tcommand_line += ` ${Options.command}`;\r\n\t\t}\r\n\r\n\t\tlet result = Liquicode.System.ExecuteProcess( command_line );\r\n\t\tif ( result.error ) { throw new Error( result.error ); }\r\n\t\tlet container_id = result.result.trim();\r\n\t\treturn container_id;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tRunContainer: RunContainer,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '832',\r\n\tmember_of: 'System',\r\n\tname: 'StartContainer',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Stops a running Docker Container.`,\r\n\tParameters: {\r\n\t\tContainerID: {\r\n\t\t\tname: 'ContainerID',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function StartContainer\n\t * @returns {string}\n\t * @description\n\t * Stops a running Docker Container.\n\t * @param {string} ContainerID\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction StartContainer( ContainerID ) \r\n\t{\r\n\t\tlet command_line = `docker start ${ContainerID}`;\r\n\t\tlet result = Liquicode.System.ExecuteProcess( command_line );\r\n\t\tif ( result.error ) { throw new Error( result.error ); }\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tStartContainer: StartContainer,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '833',\r\n\tmember_of: 'System',\r\n\tname: 'StopContainer',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Stops a running Docker Container.`,\r\n\tParameters: {\r\n\t\tContainerID: {\r\n\t\t\tname: 'ContainerID',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function StopContainer\n\t * @returns {string}\n\t * @description\n\t * Stops a running Docker Container.\n\t * @param {string} ContainerID\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction StopContainer( ContainerID ) \r\n\t{\r\n\t\tlet command_line = `docker stop ${ContainerID}`;\r\n\t\tlet result = Liquicode.System.ExecuteProcess( command_line );\r\n\t\tif ( result.error ) { throw new Error( result.error ); }\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tStopContainer: StopContainer,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '834',\r\n\tmember_of: 'System',\r\n\tname: 'KillContainer',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Kills a running Docker Container.`,\r\n\tParameters: {\r\n\t\tContainerID: {\r\n\t\t\tname: 'ContainerID',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function KillContainer\n\t * @returns {string}\n\t * @description\n\t * Kills a running Docker Container.\n\t * @param {string} ContainerID\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tfunction KillContainer( ContainerID ) \r\n\t{\r\n\t\tlet command_line = `docker kill ${ContainerID}`;\r\n\t\tlet result = Liquicode.System.ExecuteProcess( command_line );\r\n\t\tif ( result.error ) { throw new Error( result.error ); }\r\n\t\treturn;\r\n\t}\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tKillContainer: KillContainer,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet _Schema = {\r\n\tid: '900',\r\n\tname: 'Network',\r\n\ttype: 'namespace',\r\n\tsummary: 'Functions for working with networks. (nodejs only)',\r\n};\r\n\r\n\r\n//-start-jsdoc---------------------------------------------------------\r\n/**\n * @public\n * @namespace Network\n * @summary Functions for working with networks. (nodejs only)\n*/\n//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\treturn {\r\n\t\t_Schema: _Schema,\r\n\t\tAsyncDownloadFile: require( './910-Network.AsyncDownloadFile.js' )( Liquicode ).AsyncDownloadFile,\r\n\t\tAsyncGetRequest: require( './920-Network.AsyncGetRequest.js' )( Liquicode ).AsyncGetRequest,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '910',\r\n\tmember_of: 'Network',\r\n\tname: 'AsyncDownloadFile',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Download a file from an url.`,\r\n\tParameters: {},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function AsyncDownloadFile\n\t * @returns {string}\n\t * @description\n\t * Download a file from an url.\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_HTTP = require( 'http' );\r\n\tconst LIB_HTTPS = require( 'https' );\r\n\r\n\r\n\tfunction AsyncDownloadFile( Url, Filename )\r\n\t{\r\n\t\tlet http_engine = null;\r\n\t\tif ( Url.toLowerCase().startsWith( 'http:' ) ) { http_engine = LIB_HTTP; }\r\n\t\telse if ( Url.toLowerCase().startsWith( 'https:' ) ) { http_engine = LIB_HTTPS; }\r\n\t\telse { throw new Error( `Unsupported protocol. Must be either http or https.` ); }\r\n\r\n\t\treturn new Promise(\r\n\t\t\t( resolve, reject ) =>\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\thttp_engine.get(\r\n\t\t\t\t\t\tUrl,\r\n\t\t\t\t\t\tfunction ( response ) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tconst file_stream = LIB_FS.createWriteStream( Filename );\r\n\t\t\t\t\t\t\tresponse.pipe( file_stream );\r\n\t\t\t\t\t\t\tfile_stream.on(\r\n\t\t\t\t\t\t\t\t'finish',\r\n\t\t\t\t\t\t\t\tfunction ()\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tfile_stream.close();\r\n\t\t\t\t\t\t\t\t\tresolve( true );\r\n\t\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( error )\r\n\t\t\t\t{\r\n\t\t\t\t\treject( error );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\t\tAsyncDownloadFile: AsyncDownloadFile,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\n//---------------------------------------------------------------------\r\nlet Schema = {\r\n\tid: '920',\r\n\tmember_of: 'Network',\r\n\tname: 'AsyncGetRequest',\r\n\ttype: 'function',\r\n\treturns: 'string',\r\n\tdescription: `Make an http get request for a an url.`,\r\n\tParameters: {\r\n\t\tUrl: {\r\n\t\t\tname: 'Url',\r\n\t\t\ttype: 'string',\r\n\t\t\trequired: true,\r\n\t\t},\r\n\t},\r\n};\r\n\r\n\r\n//---------------------------------------------------------------------\r\nmodule.exports = function ( Liquicode )\r\n{\r\n\r\n\r\n\t//-start-jsdoc---------------------------------------------------------\r\n\t/**\n\t * @public\n\t * @function AsyncGetRequest\n\t * @returns {string}\n\t * @description\n\t * Make an http get request for a an url.\n\t * @param {string} Url\n\t*/\n\t//-end-jsdoc-----------------------------------------------------------\r\n\r\n\r\n\tconst LIB_HTTP = require( 'http' );\r\n\tconst LIB_HTTPS = require( 'https' );\r\n\r\n\r\n\tfunction AsyncGetRequest( Url )\r\n\t{\r\n\t\tlet http_engine = null;\r\n\t\tif ( Url.toLowerCase().startsWith( 'http:' ) ) { http_engine = LIB_HTTP; }\r\n\t\telse if ( Url.toLowerCase().startsWith( 'https:' ) ) { http_engine = LIB_HTTPS; }\r\n\t\telse { throw new Error( `Unsupported protocol. Must be http or https.` ); }\r\n\r\n\t\treturn new Promise(\r\n\t\t\t( resolve, reject ) =>\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\thttp_engine.get(\r\n\t\t\t\t\t\tUrl,\r\n\t\t\t\t\t\tfunction ( response ) \r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tresponse.on( 'data', data =>\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tresolve( data );\r\n\t\t\t\t\t\t\t} );\r\n\t\t\t\t\t\t} );\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( error )\r\n\t\t\t\t{\r\n\t\t\t\t\treject( error );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t};\r\n\r\n\r\n\t//---------------------------------------------------------------------\r\n\t// Return the module exports.\r\n\treturn {\r\n\t\t_Schema: Schema,\r\n\t\tAsyncGetRequest: AsyncGetRequest,\r\n\t};\r\n};\r\n","\"use strict\";\r\n\r\n\r\nvar Liquicode = {};\r\n\r\nLiquicode.version = 'v0.0.18';\r\nLiquicode.environment = 'node';\r\n\r\nLiquicode.Types = require( './000-Types/000-Types.js' )( Liquicode );\r\nLiquicode.Object = require( './100-Object/100-Object.js' )( Liquicode );\r\nLiquicode.Text = require( './200-Text/200-Text.js' )( Liquicode );\r\nLiquicode.Shapes = require( './300-Shapes/300-Shapes.js' )( Liquicode );\r\nLiquicode.Parse = require( './500-Parse/500-Parse.js' )( Liquicode );\r\nLiquicode.System = require( './800-System/800-System.js' )( Liquicode );\r\nLiquicode.Network = require( './900-Network/900-Network.js' )( Liquicode );\r\n\r\ndelete Liquicode.Types._Schema;\r\ndelete Liquicode.Object._Schema;\r\ndelete Liquicode.Text._Schema;\r\ndelete Liquicode.Shapes._Schema;\r\ndelete Liquicode.Parse._Schema;\r\ndelete Liquicode.System._Schema;\r\ndelete Liquicode.Network._Schema;\r\n\r\n\r\nmodule.exports = Liquicode;\r\n\r\n","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/liquicode-node.js\");\n",""],"names":[],"sourceRoot":""}